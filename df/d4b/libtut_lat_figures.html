<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: Weighted Figures of Merit</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatNet Builder Manual<span id="projectnumber">&#160;2.1.3-6</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('df/d4b/libtut_lat_figures.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Weighted Figures of Merit </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="libtut_lat_figures_storage"></a>
Storage</h1>
<p>In LatBuilder, the algorithms that evaluate figures of merit all store and operate on some data internally, whose representation may vary depending on the lattice (ordinary/polynomial), the type of lattice (simple/embedded) and of figure of merit under consideration.</p>
<p>First, evaluating a figure of merit for simple or for embedded lattices imposes different requirement on internal data. For example, to evaluate a coordinate-uniform figure of merit, the values \(\omega(i/n)\) (respectively \(\omega(\nu_m(i(z)/P(z)))\) of the kernel \(\omega\) for \(i=0,\dots,n-1\) ( \(n = 2^{\deg(P(z))}\) for polynomial lattices) are precomputed and stored in a vector for subsequent use. For simple lattices, the elements of the vector are stored in a natural order (see <a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html" title="Storage policy.">Storage&lt;LatticeType, EmbeddingType::UNILEVEL&gt;</a>), by increasing value of \(i\). For embedded lattices in basis \(b \in \mathbb{N}\) (respectively  \(b \in \mathbb{Z}_2[z]) 
\), the internal representation of the vector is different (see <a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html" title="Storage policy.">Storage&lt;LatticeType, EmbeddingType::MULTILEVEL&gt;</a>): it uses a permutation such that, for \(k=0,\dots,m\) where the highest-level lattice has \(n=b^m\), the values necessary to describe the level with \(b^k\) points (respectively \(2^{k \deg(b)}\) points) can be found in the first \(b^k\) elements (respectively \(2^{k \deg(b)}\) elements) stored in the permuted vector. This allows for adding the next higher level simply by extending this vector. It also simplifies performing vector operations on all different levels without having to process each level individually.</p>
<p>Second, in the case of ordinary lattices, the type of compression used also affects the internal representation of vectors. In the case of symmetric figures of merit, i.e. figures of merit that are invariant under the transformation \(a_j \mapsto n - a_j\) where \(a_j\) is any component of the generating vector, it is a waste of space and effort to represent every value internally. Considering the same example as above, only half of the values of \(\omega(i/n)\) need to be stored.</p>
<p>Finally, the size parameter of the lattice directly affects the length of the internal data vector.</p>
<p>To account for these three different aspects, the internal representation of vectors in LatBuilder is specified by a <a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html" title="Storage policy.">Storage</a> instance. These classes perform time-critical operations (such as permutation) and for that reason are not polymorphic.</p>
<p>A detailed description can be found in <a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html" title="Storage policy.">Storage</a>.</p>
<p>Consider the following example from <a class="el" href="../../d9/d8a/tutorial_2Storage_8cc-example.html">tutorial/Storage.cc</a> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;LatticeType LA, EmbeddingType ET, Compress COMP&gt;</div>
<div class="line"><span class="keywordtype">void</span> test(<span class="keyword">typename</span> <a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::Modulus</a> modulus)</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_class" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">SizeParam&lt;LA, ET&gt;</a> size(modulus);</div>
<div class="line">   <a class="code hl_class" href="../../d5/dd3/classLatBuilder_1_1Storage.html">Storage&lt;LA, ET, COMP&gt;</a> storage(size);</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;storage name: &quot;</span> &lt;&lt; storage.name() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  size parameter: &quot;</span> &lt;&lt; storage.sizeParam() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  virtual size:   &quot;</span> &lt;&lt; storage.virtualSize() &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;  actual size:    &quot;</span> &lt;&lt; storage.size() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   SET_PATH_TO_LATNETBUILDER_FOR_EXAMPLES();</div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#affd95416bf057ac963eeb8507a319884">uInteger</a> n = 16;</div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#af136576719468081a9c4735e3a2e0ec9">Polynomial</a> P = <a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(7);</div>
<div class="line">   test&lt;LatticeType::ORDINARY, EmbeddingType::UNILEVEL, Compress::NONE&gt;(n);</div>
<div class="line">   test&lt;LatticeType::ORDINARY, EmbeddingType::MULTILEVEL, Compress::NONE&gt;(n);</div>
<div class="line">   test&lt;LatticeType::ORDINARY, EmbeddingType::UNILEVEL, Compress::SYMMETRIC&gt;(n);</div>
<div class="line">   test&lt;LatticeType::ORDINARY, EmbeddingType::MULTILEVEL, Compress::SYMMETRIC&gt;(n);</div>
<div class="line"> </div>
<div class="line">   test&lt;LatticeType::POLYNOMIAL, EmbeddingType::UNILEVEL, Compress::NONE&gt;(P);</div>
<div class="line">   test&lt;LatticeType::POLYNOMIAL, EmbeddingType::MULTILEVEL, Compress::NONE&gt;(P);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The <code>StorageType</code> traits class maps a <a class="el" href="../../d1/d74/namespaceLatBuilder.html#aeac4123faa1af3717b9c10b5a9834bb1" title="Simple lattice / a sequence of embedded lattices.">EmbeddingType</a> value to a type of storage through template specialization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html" title="Storage policy.">Storage</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_figures_simple"></a>
A Simple Example</h1>
<p>The example from <a class="el" href="../../d8/d01/tutorial_2WeightedFigureOfMerit_8cc-example.html">tutorial/WeightedFigureOfMerit.cc</a> illustrates how to instantiate a weighted figure of merit and perform a search for the best Korobov lattice. First we instantiate the sequence <code>latSeq</code> of lattice definitions roughly as in the example from <a class="el" href="../../d5/d48/libtut_lat_latseq.html#libtut_lat_latseq_korobov">Korobov Sequences</a> . Next, we instantiate a weighted spectral figure of merit, using a sum as its accumulator, and product weights: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> weights = unique&lt;LatticeTester::ProductWeights&gt;();</div>
<div class="line">   weights-&gt;setDefaultWeight(0.7);</div>
<div class="line"></div>
<div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d4/de2/classLatBuilder_1_1ProjDepMerit_1_1Spectral.html">ProjDepMerit::Spectral&lt;LatticeTester::NormaBestLat&lt;Real&gt;</a>&gt; ProjDep;</div>
<div class="line">   <a class="code hl_class" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html">WeightedFigureOfMerit&lt;ProjDep, Functor::Max&gt;</a> figure(2, std::move(weights));</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;figure of merit: &quot;</span> &lt;&lt; figure &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Then, we instantiate a sequence of projections to which the figure of merit applies with: </p><div class="fragment"><div class="line">   <a class="code hl_class" href="../../d8/d34/classLatticeTester_1_1CoordinateSets_1_1FromRanges.html">LatticeTester::CoordinateSets::FromRanges</a> allProjections(</div>
<div class="line">         1, latSeq.latDimension(),     <span class="comment">// range for dimension</span></div>
<div class="line">         0, latSeq.latDimension() - 1  <span class="comment">// range for coordinate index</span></div>
<div class="line">         );</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;projections: &quot;</span> &lt;&lt; allProjections &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> We also allocate a storage instance for simple lattices with appropriate compression: </p><div class="fragment"><div class="line">   test(<a class="code hl_class" href="../../d5/dd3/classLatBuilder_1_1Storage.html">Storage&lt;LatticeType::ORDINARY, EmbeddingType::UNILEVEL, Compress::SYMMETRIC&gt;</a>(19), dim);</div>
</div><!-- fragment --><p> We define an observer which will keep track of the best candidate lattice: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;LatticeType LA&gt;</div>
<div class="line"><span class="keyword">class </span>Observer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   <span class="keyword">typedef</span> LatBuilder::LatDef&lt;LA, EmbeddingType::UNILEVEL&gt; LatDef;</div>
<div class="line"> </div>
<div class="line">   Observer() { reset(); }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// initializes the best observed merit value to infinity</span></div>
<div class="line">   <span class="keywordtype">void</span> reset() { m_bestMerit = std::numeric_limits&lt;Real&gt;::infinity(); }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// returns the best observed lattice</span></div>
<div class="line">   <span class="keyword">const</span> LatDef&amp; bestLat() { <span class="keywordflow">return</span> m_bestLat; }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// returns the best observed merit value</span></div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#acaaada8fcc395f28434f8a32a97b03ca">Real</a> bestMerit() { <span class="keywordflow">return</span> m_bestMerit; }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// notifies the observer that the merit value of a new candidate lattice has</span></div>
<div class="line">   <span class="comment">// been observed; updates the best observed candidate lattice if necessary</span></div>
<div class="line">   <span class="keywordtype">void</span> observe(<span class="keyword">const</span> LatDef&amp; lat, Real merit)</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; lat;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Merit: &quot;</span> &lt;&lt; merit;</div>
<div class="line">      <span class="keywordflow">if</span> (merit &lt; m_bestMerit) {</div>
<div class="line">         std::cout &lt;&lt; <span class="stringliteral">&quot; &lt;-- best&quot;</span>;</div>
<div class="line">         m_bestMerit = merit;</div>
<div class="line">         m_bestLat = lat;</div>
<div class="line">      }</div>
<div class="line">      std::cout &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">   LatDef m_bestLat;</div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#acaaada8fcc395f28434f8a32a97b03ca">Real</a> m_bestMerit;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Finally, we can iterate through all lattices and display the best observed candidate lattice: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code hl_function" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#a682f778d21855daf4fb333c0947baa97">eval</a> = figure.evaluator(storage);</div>
<div class="line">   Observer&lt;LA&gt; obs;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lat : latSeq) {</div>
<div class="line">      <span class="comment">// compute merit value of lattice for all projections</span></div>
<div class="line">      <span class="keyword">auto</span> merit = <a class="code hl_function" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#a682f778d21855daf4fb333c0947baa97">eval</a>(lat, allProjections, initialMerit);</div>
<div class="line">      <span class="comment">// notify the observer</span></div>
<div class="line">      obs.observe(lat, merit);</div>
<div class="line">   }</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;BEST LATTICE: &quot;</span> &lt;&lt; std::endl &lt;&lt; obs.bestLat() &lt;&lt; <span class="stringliteral">&quot;Merit value: &quot;</span> &lt;&lt; obs.bestMerit() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The purpose of the <code>initialMerit</code> object is to store the value of the figure of merit for projections other than that for which it is currently being evaluated (all projections, here). Thus, it is possible to split the evaluation of the figure of merit over different sets of coordinates. It is particularly useful in the case of component-by-component construction, where it can be used to store the merit value of the base lattice (before a component is appended to the generating vector). Here, it simply contains the value <code>0.0</code>: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> initialMerit = storage.createMeritValue(0.0);</div>
</div><!-- fragment --><p> The output of this example is: </p><pre class="fragment">figure of merit: Projection Dependent Merit: spectral^1 (symmetric) - Accumulator: Max
Norm Type: 2
Weights: ProductWeights([], default=0.7)
projections: [{0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 1, 1]
Merit: 5.37513 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 2, 4]
Merit: 2.15005 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 3, 9]
Merit: 2.15005
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 16]
Merit: 1.07503 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 5, 6]
Merit: 1.07503
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 6, 17]
Merit: 2.15005
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 7, 11]
Merit: 1.0257 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 8, 7]
Merit: 1.0257
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 9, 5]
Merit: 2.15005
BEST LATTICE: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 7, 11]
Merit value: 1.0257
</pre><dl class="section remark"><dt>Remarks</dt><dd>A weighted \(\mathcal P_\alpha\) discrepancy could be obtained by replacing: <div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d4/de2/classLatBuilder_1_1ProjDepMerit_1_1Spectral.html">ProjDepMerit::Spectral&lt;LatticeTester::NormaBestLat&lt;Real&gt;</a>&gt; ProjDep;</div>
<div class="line">   <a class="code hl_class" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html">WeightedFigureOfMerit&lt;ProjDep, Functor::Max&gt;</a> figure(2, std::move(weights));</div>
</div><!-- fragment --> with: <div class="fragment"><div class="line"><span class="keyword">typedef</span> ProjDepMerit::CoordUniform&lt;Kernel::PAlpha&gt; ProjDep;</div>
<div class="line">WeightedFigureOfMerit&lt;ProjDep, Functor::Sum&gt; figure(2, std::move(weights), ProjDep(2));</div>
</div><!-- fragment --></dd></dl>
<p>The same applies for polynomial lattices. For example, we can look for the best Korobov lattice with respect to \(\mathcal P_{\alpha}\): we define the weighted figure of merit as follows: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> ProjDepMerit::CoordUniform&lt;Kernel::PAlphaTilde&gt; ProjDep;</div>
<div class="line">WeightedFigureOfMerit&lt;ProjDep, Functor::Sum&gt; figure(2, std::move(weights), ProjDep(2));</div>
</div><!-- fragment --><p>We then execute </p><div class="fragment"><div class="line">   test(Storage&lt;LatticeType::POLYNOMIAL, EmbeddingType::UNILEVEL, Compress::NONE&gt;(PolynomialFromInt(13)), dim);</div>
</div><!-- fragment --><p> which gives the output: </p><pre class="fragment">figure of merit: Projection Dependent Merit: P2_PLR - Accumulator: Sum
Norm Type: 2
Weights: ProductWeights([], default=0.7)
projections: [{0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}]
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  1
  1
Merit: 2.18057 &lt;-- best
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  2
  4
Merit: 1.0617 &lt;-- best
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  3
  5
Merit: 1.04103 &lt;-- best
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  4
  7
Merit: 1.04103
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  5
  6
Merit: 1.02036 &lt;-- best
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  6
  3
Merit: 1.0617
Polynomial Lattice - Modulus = 13 - Generating vector = 
  1
  7
  2
Merit: 1.02036
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> <a class="el" href="../../d7/d49/namespaceLatBuilder_1_1ProjDepMerit.html" title="Projection-dependent figures of merit.">ProjDepMerit</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_figures_signals"></a>
A Improved Example Using Signals</h1>
<p>The evaluation of the figure of merit by <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> is performed by evaluating term-by-term a sum over a set of projections of a lattice. If, during the progress of evaluating the sum, the value partial sum becomes larger than the smallest merit value of other candidate lattices already evaluated, then there is no need to finish evaluating the sum. The same reasoning holds for a maximum instead of a sum too. The example in <a class="el" href="../../d0/d91/tutorial_2WeightedFigureOfMeritSignals_8cc-example.html">tutorial/WeightedFigureOfMeritSignals.cc</a> shows how the evaluation process can be aborted using <em>signals</em>.</p>
<p>After contributing every new term into the sum (or maximum), <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> emits the WeightedFigureOfMerit::onProgress() signal, passing the current cumulated value as its argument. This signal can be connected to any function (a signal listener) which takes for argument a constant reference to a <a class="el" href="../../d8/d18/structLatBuilder_1_1MeritFilterTraits.html">MeritValue</a> instance. If the signal listener returns <code>true</code>, <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> continues the evaluation of the figure of merit; otherwise, it is aborted and the figure of merit evaluates to infinity. For example, we define: </p><div class="fragment"><div class="line">   <span class="keywordtype">bool</span> onProgress(Real merit)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ <span class="keywordflow">return</span> merit &lt; m_bestMerit; }</div>
</div><!-- fragment --><p> in the <code>Observer</code> class. We also define a listener for WeightedFigureOfMerit::onAbort() which is emitted by <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> upon abortion and which passes the rejected candidate lattice as its argument: </p><div class="fragment"><div class="line">   <span class="keywordtype">void</span> onAbort(<span class="keyword">const</span> LatDef&amp; lat)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ std::cout &lt;&lt; <span class="stringliteral">&quot;rejected:&quot;</span> &lt;&lt; std::endl &lt;&lt; lat; }</div>
</div><!-- fragment --><p> Then, we connect the listener to the signals with: </p><div class="fragment"><div class="line">   Observer&lt;LA&gt; obs;</div>
<div class="line">   <a class="code hl_function" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#a682f778d21855daf4fb333c0947baa97">eval</a>.onProgress().connect(boost::bind(&amp;Observer&lt;LA&gt;::onProgress, &amp;obs, _1));</div>
<div class="line">   <a class="code hl_function" href="../../d6/db5/namespaceLatBuilder_1_1Task.html#a682f778d21855daf4fb333c0947baa97">eval</a>.onAbort().connect(boost::bind(&amp;Observer&lt;LA&gt;::onAbort, &amp;obs, _1));</div>
</div><!-- fragment --><p>With these changes, the output becomes: </p><pre class="fragment">figure of merit: Projection Dependent Merit: spectral^1 (symmetric) - Accumulator: Max
Norm Type: 2
Weights: ProductWeights([], default=0.7)
projections: [{0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 1, 1]
Merit: 5.37513 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 2, 4]
Merit: 2.15005 &lt;-- best
rejected:
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 3, 9]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 3, 9]
Merit: inf
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 16]
Merit: 1.07503 &lt;-- best
rejected:
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 5, 6]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 5, 6]
Merit: inf
rejected:
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 6, 17]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 6, 17]
Merit: inf
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 7, 11]
Merit: 1.0257 &lt;-- best
rejected:
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 8, 7]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 8, 7]
Merit: inf
rejected:
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 9, 5]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 9, 5]
Merit: inf
BEST LATTICE: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 7, 11]
Merit value: 1.0257
</pre><h1 class="doxsection"><a class="anchor" id="libtut_lat_figures_cbc_simple"></a>
A Simple Example Using CBC Construction</h1>
<p>We can modify the example from <a class="el" href="#libtut_lat_figures_simple">A Simple Example</a> to implement CBC construction as illustrated in <a class="el" href="../../d5/d48/libtut_lat_latseq.html#libtut_lat_latseq_cbc">Component-by-Component Sequences</a>. The complete example can be found in <a class="el" href="../../d3/dd3/tutorial_2WeightedFigureOfMeritCBC_8cc-example.html">tutorial/WeightedFigureOfMeritCBC.cc</a>. The first step is to declare a base lattice: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> baseLat = <a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#abadfe64a339aad300160a5822c017af5">createLatDef</a>(storage.sizeParam());</div>
</div><!-- fragment --><p> and to create a loop over its dimension: </p><div class="fragment"><div class="line">   <span class="keywordflow">while</span> (baseLat.dimension() &lt; dimension) {</div>
<div class="line"> </div>
<div class="line">      <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#a4960612b7301b40894ad276bd6337edb">Dimension</a> baseDim = baseLat.dimension();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> latSeq = <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">LatSeq::cbc</a>(</div>
<div class="line">            baseLat,</div>
<div class="line">            Coprime(baseDim == 0 ? <a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::TrivialModulus</a> : storage.sizeParam().modulus())</div>
<div class="line">            );</div>
</div><!-- fragment --><p> where we instantiate a new lattice sequence every time the dimension of the base lattice is increased. When the dimension of the base lattice is zero, we need only consider 1 as a candidate value for the first component of the generating vector, whence the condition on <code>baseDim</code> above. Instead of covering all projections, we need only consider the projections that include the new coordinate in the generating vector: </p><div class="fragment"><div class="line">      <span class="comment">// base projections</span></div>
<div class="line">      FromRanges baseProjections{</div>
<div class="line">            0, baseDim,     <span class="comment">// range for dimension</span></div>
<div class="line">            0, baseDim - 1  <span class="comment">// range for coordinate index</span></div>
<div class="line">            };</div>
<div class="line">      <span class="comment">// add current coordinate to the base projections</span></div>
<div class="line">      AddCoordinate&lt;FromRanges&gt; newProjections(</div>
<div class="line">            baseProjections,</div>
<div class="line">            baseDim         <span class="comment">// current coordinate index</span></div>
<div class="line">            );</div>
</div><!-- fragment --><p> The minimization loop is unchanged, except that <code>allProjections</code> is replace with <code>newProjections</code>. Finally, <code>baseLat</code> and <code>initialMerit</code> must be updated based on the best observed candidate lattice: </p><div class="fragment"><div class="line">      baseLat = obs.bestLat();</div>
<div class="line">      initialMerit = obs.bestMerit();</div>
</div><!-- fragment --><p> After these changes, the output becomes: </p><pre class="fragment">figure of merit: Projection Dependent Merit: spectral^1 (symmetric) - Accumulator: Max
Norm Type: 2
Weights: ProductWeights([], default=0.7)
CBC search for dimension: 1
base lattice: 
Ordinary Lattice - Modulus = 19 - Generating vector = []
base merit value: 0
new projections: [{0}]
Ordinary Lattice - Modulus = 19 - Generating vector = [1]
Merit: 0.7 &lt;-- best
BEST LATTICE: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1]
Merit value: 0.7
CBC search for dimension: 2
base lattice: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1]
base merit value: 0.7
new projections: [{1}, {0,1}]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 1]
Merit: 5.37513 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 2]
Merit: 2.15005 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 3]
Merit: 1.07503 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4]
Merit: 0.7 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 5]
Merit: 0.7
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 6]
Merit: 1.07503
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 7]
Merit: 0.826943
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 8]
Merit: 0.826943
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 9]
Merit: 2.15005
BEST LATTICE: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4]
Merit value: 0.7
CBC search for dimension: 3
base lattice: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4]
base merit value: 0.7
new projections: [{2}, {0,2}, {1,2}, {0,1,2}]
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 1]
Merit: 5.37513 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 2]
Merit: 2.15005 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 3]
Merit: 1.07503 &lt;-- best
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 4]
Merit: 5.37513
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 5]
Merit: 1.07503
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 6]
Merit: 1.07503
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 7]
Merit: 1.07503
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 8]
Merit: 2.15005
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 9]
Merit: 2.15005
BEST LATTICE: 
Ordinary Lattice - Modulus = 19 - Generating vector = [1, 4, 3]
Merit value: 1.07503
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../index.html">LatNet Builder Manual</a></li><li class="navelem"><a href="../../da/d6f/libtut.html">Library Tutorial</a></li><li class="navelem"><a href="../../da/d10/libtut_lat.html">LatBuilder tutorial</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for LatNet Builder Manual by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
