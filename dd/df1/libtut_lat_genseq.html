<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: Sequences of Generator Values</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatNet Builder Manual<span id="projectnumber">&#160;2.1.3-6</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dd/df1/libtut_lat_genseq.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sequences of Generator Values </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Search for a good generating vector involves enumerating the values its components can take. The representation of search spaces in LatBuilder is based on sequences of possible values for the components of the generating vector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d60/namespaceLatBuilder_1_1GenSeq.html" title="Sequences of generator values.">GenSeq</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_genseq_coprime"></a>
Coprime Integers-Polynomials</h1>
<p>In the general case, one normally needs to enumerate all integers (respectively polynomials) that are relatively prime with the modulus \(n\) (respectively \(P\)) of the lattice point set. This is implemented by the class template <a class="el" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html" title="Indexed sequence of generating values: -For ordinary lattices: integers coprime with a specified modu...">GenSeq::GeneratingValues</a>.</p>
<p>For ordinary lattices, some figures of merit are invariant under the transformation  \(a \mapsto n -
a\) where \(a\) is any component of the generating vector. When using such a <em>symmetric</em> figure of merit, redundancy can be avoided by enumerating only the first half of the sequence of integers coprime with \(n\), i.e. by compressing the search space. <br  />
</p>
<p>In that case, we pass <code>Compress::Symmetric</code> as second template argument to <a class="el" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html" title="Indexed sequence of generating values: -For ordinary lattices: integers coprime with a specified modu...">GenSeq::GeneratingValues</a>: </p><div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LatticeType::ORDINARY, Compress::SYMMETRIC&gt;</a> HalfSeqIntegers;</div>
</div><!-- fragment --><p>Otherwise, we pass <code>Compress::None</code>: </p><div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LatticeType::ORDINARY, Compress::NONE&gt;</a> WholeSeqIntegers;</div>
</div><!-- fragment --><p>For polynomial lattices, to our knowledge, no symmetry properties have been identified so far:</p>
<div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LatticeType::POLYNOMIAL, Compress::NONE&gt;</a> WholeSeqPolynomials;</div>
</div><!-- fragment --><p>These concepts are illustrated in <a class="el" href="../../da/d14/tutorial_2GenSeqGeneratingValues_8cc-example.html">tutorial/GenSeqGeneratingValues.cc</a> :</p>
<ul>
<li><p class="startli">For ordinary lattices: </p><div class="fragment"><div class="line">   <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#affd95416bf057ac963eeb8507a319884">uInteger</a> n : {7, 8, 12}) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;lattice modulus: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;    whole sequence: &quot;</span> &lt;&lt; WholeSeqIntegers(n) &lt;&lt; std::endl;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;     half sequence: &quot;</span> &lt;&lt; HalfSeqIntegers(n) &lt;&lt; std::endl;</div>
<div class="line">   }</div>
</div><!-- fragment --><p class="startli">The ouput of the above code is: </p><pre class="fragment">lattice modulus: 7
    whole sequence: [1, 2, 3, 4, 5, 6]
     half sequence: [1, 2, 3]
lattice modulus: 8
    whole sequence: [1, 3, 5, 7]
     half sequence: [1, 3]
lattice modulus: 12
    whole sequence: [1, 7, 5, 11]
     half sequence: [1, 5]
</pre></li>
<li><p class="startli">For polynomial lattices: </p><div class="fragment"><div class="line">   <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#af136576719468081a9c4735e3a2e0ec9">Polynomial</a> P : {<a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(10), <a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(13)}) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;lattice modulus: &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;    whole sequence: &quot;</span> &lt;&lt; WholeSeqPolynomials(P) &lt;&lt; std::endl;</div>
<div class="line">      </div>
<div class="line">   }</div>
</div><!-- fragment --><p class="startli">The ouput of the above code is: </p><pre class="fragment">lattice modulus: 10
    whole sequence: [1, 7]
lattice modulus: 13
    whole sequence: [1, 2, 3, 4, 5, 6, 7]
</pre></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_genseq_random"></a>
Random Traversal</h1>
<p>Sometimes, as with random Korobov or random CBC, it is necessary to randomly select a certain number of elements from a <a class="el" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html" title="Indexed sequence of generating values: -For ordinary lattices: integers coprime with a specified modu...">GenSeq::GeneratingValues</a> instance. <a class="el" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html" title="Indexed sequence of generating values: -For ordinary lattices: integers coprime with a specified modu...">GenSeq::GeneratingValues</a> optionally takes a third template arguments that specifies a method of traversal of its values; it defaults to <a class="el" href="../../d8/d04/classLatBuilder_1_1Traversal_1_1Forward.html" title="Range-based forward traversal type.">Traversal::Forward</a> which enumerates the values in their original order in the sequence. It can be replaced with <a class="el" href="../../dc/d4c/classLatBuilder_1_1Traversal_1_1Random.html" title="Random traversal type.">Traversal::Random</a> for the above purpose:</p>
<div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../dc/d4c/classLatBuilder_1_1Traversal_1_1Random.html">Traversal::Random&lt;LFSR258&gt;</a> Trav;</div>
<div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LatticeType::ORDINARY, Compress::SYMMETRIC, Trav&gt;</a> RandomSeq;</div>
</div><!-- fragment --><p>The traversal type <a class="el" href="../../dc/d4c/classLatBuilder_1_1Traversal_1_1Random.html" title="Random traversal type.">Traversal::Random</a> also takes a template argument that specifies the type of random generator to use. We use <a class="el" href="../../d6/d6c/classLatBuilder_1_1LFSR258.html" title="LFSR258 pseudo-random generator by L&#39;Ecuyer.">LFSR258</a> in our example, but any C++11-compliant random engine could be used. Next, a random traversal object must be instantiated with the desired number <code>r</code> of random samples:</p>
<div class="fragment"><div class="line">   Trav trav(r);</div>
</div><!-- fragment --><p>Then, the sequence object can be instantiated with the lattice size <code>n</code>, and the traversal object:</p>
<div class="fragment"><div class="line">      RandomSeq seq(n, trav);</div>
</div><!-- fragment --><p>A complete example can be found in <a class="el" href="../../d5/d9b/tutorial_2GenSeqRandom_8cc-example.html">tutorial/GenSeqRandom.cc</a> : </p><div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../dc/d4c/classLatBuilder_1_1Traversal_1_1Random.html">Traversal::Random&lt;LFSR258&gt;</a> Trav;</div>
<div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LatticeType::ORDINARY, Compress::SYMMETRIC, Trav&gt;</a> RandomSeq;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">size_t</span> r = 4; <span class="comment">// 4 random samples</span></div>
<div class="line"></div>
<div class="line">   Trav trav(r);</div>
<div class="line">   <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#affd95416bf057ac963eeb8507a319884">uInteger</a> n : {31, 256}) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;lattice size: &quot;</span> &lt;&lt; n</div>
<div class="line">         &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; trav.size() &lt;&lt; <span class="stringliteral">&quot; random samples)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      RandomSeq seq(n, trav);</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;          sequence: &quot;</span> &lt;&lt; seq &lt;&lt; std::endl;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;     same sequence: &quot;</span> &lt;&lt; seq &lt;&lt; std::endl;</div>
<div class="line">      seq.randomGenerator().jump();</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;    other sequence: &quot;</span> &lt;&lt; seq &lt;&lt; std::endl;</div>
<div class="line">   }</div>
</div><!-- fragment --><p> The output of the above code is: </p><pre class="fragment">lattice size: 31 (4 random samples)
          sequence: [11, 2, 6, 15]
     same sequence: [11, 2, 6, 15]
    other sequence: [5, 14, 6, 8]
lattice size: 256 (4 random samples)
          sequence: [115, 71, 61, 51]
     same sequence: [115, 71, 61, 51]
    other sequence: [31, 115, 25, 37]
</pre><p>Note that GenSeq::Random stores its own copy of the random engine, so that successive iteration over the same random sequence objects yields the same sequence of values. To obtain a different random selection of values, the initial state of the random generator must be changed. The <a class="el" href="../../d6/d6c/classLatBuilder_1_1LFSR258.html" title="LFSR258 pseudo-random generator by L&#39;Ecuyer.">LFSR258</a> generator exposes a <code>jump()</code> function for this purpose: </p><div class="fragment"><div class="line">      seq.randomGenerator().jump();</div>
</div><!-- fragment --><p>In some situations, the number <code>r</code> of random samples is not known in advance. In that case, the preferred method is to instantiate the traversal object without passing the argument <code>r</code>, which defaults to infinity, then to add a stopping condition in loops that iterate over the elements of the sequence.</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_genseq_cyclicgroup"></a>
Cyclic Groups</h1>
<p>For an integer \(n\) power of prime base, the multiplicative group of integers coprime with \(n\) is a cyclic group (or a product of two cyclic groups if \(2^3|n\)). For an irreducible polynomial \(P\), the multiplicative group of polynomials coprime with \(P\) is a cyclic group.</p>
<p>In these cases, the class template <a class="el" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html" title="Cyclic group.">GenSeq::CyclicGroup</a> can be used to enumerate the elements of the cyclic group of integers modulo \(n\) (respectively polynomials modulo \(P\)) in the natural group order where the \(i\)-th element is \(g^i \bmod n\) ( \(g^i \bmod P\) respectively), where \(g\) is the group generator. This is useful in particular to perform fast CBC exploration. Like <a class="el" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html" title="Indexed sequence of generating values: -For ordinary lattices: integers coprime with a specified modu...">GenSeq::GeneratingValues</a>, <a class="el" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html" title="Cyclic group.">GenSeq::CyclicGroup</a> takes a compression type as the second template argument. This is illustrated in <a class="el" href="../../d3/dc5/tutorial_2GenSeqCyclicGroup_8cc-example.html">tutorial/GenSeqCyclicGroup.cc</a> : </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html">GenSeq::CyclicGroup&lt;LatticeType::ORDINARY, Compress::NONE&gt;</a> WholeIntSeq;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html">GenSeq::CyclicGroup&lt;LatticeType::ORDINARY, Compress::SYMMETRIC&gt;</a> HalfIntSeq;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html">GenSeq::CyclicGroup&lt;LatticeType::POLYNOMIAL, Compress::NONE&gt;</a> WholePolySeq;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> displayIntSeq(<span class="keywordtype">int</span> base, <span class="keywordtype">int</span> power)</div>
<div class="line">{</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;lattice modulus: &quot;</span> &lt;&lt; base &lt;&lt; <span class="stringliteral">&quot;^&quot;</span> &lt;&lt; <a class="code hl_function" href="../../d2/d5a/namespaceNTL.html#a369678174d23f9f3b894bbcb332ada72">power</a> &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;    whole sequence: &quot;</span> &lt;&lt; WholeIntSeq(base, power) &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;     half sequence: &quot;</span> &lt;&lt; HalfIntSeq(base, power) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> displayPolySeq(<a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#af136576719468081a9c4735e3a2e0ec9">Polynomial</a> base, <span class="keywordtype">int</span> power)</div>
<div class="line">{</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;polynomial lattice modulus: &quot;</span> &lt;&lt; base &lt;&lt; <span class="stringliteral">&quot;^&quot;</span> &lt;&lt; <a class="code hl_function" href="../../d2/d5a/namespaceNTL.html#a369678174d23f9f3b894bbcb332ada72">power</a> &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;    whole sequence: &quot;</span> &lt;&lt; WholePolySeq(base, power) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   SET_PATH_TO_LATNETBUILDER_FOR_EXAMPLES();</div>
<div class="line">   displayIntSeq(7, 1);</div>
<div class="line">   displayIntSeq(2, 3);</div>
<div class="line">   displayIntSeq(3, 2);</div>
<div class="line">   displayPolySeq(<a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(13),1); </div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The output of the above code is: </p><pre class="fragment">lattice modulus: 7^1
    whole sequence: [1, 3, 2, 6, 4, 5]
     half sequence: [1, 3, 2]
lattice modulus: 2^3
    whole sequence: [1, 5, 7, 3]
     half sequence: [1, 3]
lattice modulus: 3^2
    whole sequence: [1, 2, 4, 8, 7, 5]
     half sequence: [1, 2, 4]
polynomial lattice modulus: 13^1
    whole sequence: [1, 2, 4, 5, 7, 3, 6]
</pre><p> For ordinary lattices, and in the symmetric case, each value \(a\) is mapped to \(\min\{a, n-a\}\). Note that in the polynomial case, the group is cyclic if the modulus is irreducible. This is only the case if <code>power</code> equals 1. Otherwise the group is not cyclic. This explains why the fast-CBC algorithm for polynomial lattice rules is only available for irreducible modulus. As a consequence, the fast-CBC construction is not available for embedded polynomial lattice rules.</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_genseq_vector"></a>
Vectors of Integer/Polynomial Sequences</h1>
<p>Construction algorithms often consider a distinct sequence of possible values <br  />
 for each component of the generating vector. When distinct random selection of sequence elements are required for each coordinate, as with random CBC or plain random constructions; in this case, the initial state of the random generator must be different for each coordinate, as explained in <a class="el" href="#libtut_lat_genseq_random">Random Traversal</a>. This functionality is provided by the convenience class template <a class="el" href="../../d5/d28/structLatBuilder_1_1GenSeq_1_1VectorCreator.html" title="Creator for vectors of sequences of generator values.">GenSeq::VectorCreator</a>, which automatically calls jump() on the random generator between different coordinates if the traversal method is <a class="el" href="../../dc/d4c/classLatBuilder_1_1Traversal_1_1Random.html" title="Random traversal type.">Traversal::Random</a>.</p>
<p>A vector of <code>dim</code> sequences of type <code>Seq</code> with size parameter <code>n</code> can be created with: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> vec = <a class="code hl_function" href="../../d5/d28/structLatBuilder_1_1GenSeq_1_1VectorCreator.html#afa2884c36b163c8778b818f8fb896fd0">GenSeq::VectorCreator&lt;Seq&gt;::create</a>(n, dim);</div>
</div><!-- fragment --><p> In most situations when constructing rank-1 lattices, we consider only the value 1 for the first component. For that purpose, we can replace the first integer (respectively polynomial) sequence with a singleton that contains only the value 1 with: </p><div class="fragment"><div class="line">   vec[0] = <a class="code hl_function" href="../../d0/d17/structLatBuilder_1_1GenSeq_1_1Creator.html#a95a8c0648a210ab9f9b5822b35420cfe">GenSeq::Creator&lt;Seq&gt;::create</a>(n0);</div>
</div><!-- fragment --><p> where \(n_0\) is the size parameter with modulus 2 (or \(P(z)=z\) for polynomial lattices). A full example can be found in <a class="el" href="../../d2/d49/tutorial_2GenSeqVector_8cc-example.html">tutorial/GenSeqVector.cc</a> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;LatticeType LA&gt;</div>
<div class="line"><span class="keywordtype">void</span> SeqVector(<span class="keyword">typename</span> <a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::Modulus</a> modulus){</div>
<div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LA, Compress::NONE&gt;</a> Seq;</div>
<div class="line">   <a class="code hl_class" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">SizeParam&lt;LA, EmbeddingType::UNILEVEL&gt;</a> n(modulus);      <span class="comment">// lattice modulus</span></div>
<div class="line">   <a class="code hl_class" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">SizeParam&lt;LA, EmbeddingType::UNILEVEL&gt;</a> n0(<a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::TrivialModulus</a>);   <span class="comment">// fake lattice modulus to obtain a single value (1)</span></div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#a4960612b7301b40894ad276bd6337edb">Dimension</a> dim = 3;</div>
<div class="line">   <span class="keyword">auto</span> vec = <a class="code hl_function" href="../../d5/d28/structLatBuilder_1_1GenSeq_1_1VectorCreator.html#afa2884c36b163c8778b818f8fb896fd0">GenSeq::VectorCreator&lt;Seq&gt;::create</a>(n, dim);</div>
<div class="line">   vec[0] = <a class="code hl_function" href="../../d0/d17/structLatBuilder_1_1GenSeq_1_1Creator.html#a95a8c0648a210ab9f9b5822b35420cfe">GenSeq::Creator&lt;Seq&gt;::create</a>(n0);</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;lattice modulus: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;    generating value sequences: &quot;</span> &lt;&lt; vec &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">   SeqVector&lt;LatticeType::ORDINARY&gt;(7);</div>
<div class="line">   SeqVector&lt;LatticeType::POLYNOMIAL&gt;(<a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(7));</div>
</div><!-- fragment --><p> The output of the above code is: </p><pre class="fragment">lattice modulus: 7
    generating value sequences: [[1], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]
lattice modulus: 7
    generating value sequences: [[1], [1, 2, 3], [1, 2, 3]]
</pre><p>For random sequence types, the number of random samples can be passed as an additional optional argument to <a class="el" href="../../d5/d28/structLatBuilder_1_1GenSeq_1_1VectorCreator.html#afa2884c36b163c8778b818f8fb896fd0" title="Creates a new sequence object.">GenSeq::VectorCreator::create()</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;LatticeType LA&gt;</div>
<div class="line"><span class="keywordtype">void</span> RandomSeqVector(<span class="keyword">typename</span> <a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::Modulus</a> modulus){</div>
<div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues&lt;LA, Compress::NONE, Traversal::Random&lt;LFSR258&gt;</a>&gt; RandomSeq;</div>
<div class="line">   <a class="code hl_class" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">SizeParam&lt;LA, EmbeddingType::UNILEVEL&gt;</a> n(modulus);      <span class="comment">// lattice modulus</span></div>
<div class="line">   <a class="code hl_class" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">SizeParam&lt;LA, EmbeddingType::UNILEVEL&gt;</a> n0(<a class="code hl_struct" href="../../dd/d0c/structLatBuilder_1_1LatticeTraits.html">LatticeTraits&lt;LA&gt;::TrivialModulus</a>);   <span class="comment">// fake lattice modulus to obtain a single value (1)</span></div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#a4960612b7301b40894ad276bd6337edb">Dimension</a> dim = 3;</div>
<div class="line">  </div>
<div class="line">   <span class="keyword">auto</span> randVec = <a class="code hl_function" href="../../d5/d28/structLatBuilder_1_1GenSeq_1_1VectorCreator.html#afa2884c36b163c8778b818f8fb896fd0">GenSeq::VectorCreator&lt;RandomSeq&gt;::create</a>(n, dim, 5);</div>
<div class="line">   randVec[0] = <a class="code hl_function" href="../../d0/d17/structLatBuilder_1_1GenSeq_1_1Creator.html#a95a8c0648a210ab9f9b5822b35420cfe">GenSeq::Creator&lt;RandomSeq&gt;::create</a>(n0, 1); <span class="comment">// replace 1st with singleton</span></div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;lattice modulus: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;    random generating value sequences: &quot;</span> &lt;&lt; randVec &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">   RandomSeqVector&lt;LatticeType::ORDINARY&gt;(7);</div>
<div class="line">   RandomSeqVector&lt;LatticeType::POLYNOMIAL&gt;(<a class="code hl_function" href="../../d1/d74/namespaceLatBuilder.html#a38d25c3ae13fc175af3c80b72a596751">PolynomialFromInt</a>(7));</div>
</div><!-- fragment --><p> The output of the above code is: </p><pre class="fragment">lattice modulus: 7
    random generating value sequences: [[1], [2, 2, 3, 5, 4], [4, 5, 4, 3, 6]]
lattice modulus: 7
    random generating value sequences: [[1], [2, 2, 3, 2, 1], [1, 2, 1, 3, 3]]
</pre><p> Distinct random sequences are automatically created.</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_genseq_extend"></a>
Extension of the Number of Points</h1>
<p>A lattice with \(b^m\) points in dimension \(s\) and generating vector \(\boldsymbol a = (a_1,\dots,a_s)\) can be extended to \(b^{m+1}\) points by appending a \(m+1\)-st digit in base \(b\) to the left of each \(a_j\). It is easy to verify that the original lattice is indeed embedded in the extended lattice. The following instruction shows how to instantiate a sequence of generator values <code>seq</code> that adds a \(m+1\)-st digit in base <code>b</code>, where <code>numPoints =
b</code> \(^m\) to the left of the \(m\) digits in base <code>b</code> of the integer <code>gen</code> (which stands for any of the \(a_j\)'s): </p><div class="fragment"><div class="line">      <a class="code hl_class" href="../../d8/df0/classLatBuilder_1_1GenSeq_1_1Extend.html">GenSeq::Extend&lt;LatticeType::ORDINARY&gt;</a> seq(b * numPoints, numPoints, gen);</div>
</div><!-- fragment --><p> In practice, <code>low</code> would be one of the \(a_j\)'s. To add two digits instead of one, the first constructor argument <code>b *
numPoints</code> must be replaced with <code>b * b * numPoints</code>.</p>
<p>The same applies for the polynomial case: </p><div class="fragment"><div class="line">   <a class="code hl_class" href="../../d8/df0/classLatBuilder_1_1GenSeq_1_1Extend.html">GenSeq::Extend&lt;LatticeType::POLYNOMIAL&gt;</a> seq(base * P, P, generator);</div>
</div><!-- fragment --><p> A complete example can be found in <a class="el" href="../../de/dac/tutorial_2GenSeqExtend_8cc-example.html">tutorial/GenSeqExtend.cc</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../index.html">LatNet Builder Manual</a></li><li class="navelem"><a href="../../da/d6f/libtut.html">Library Tutorial</a></li><li class="navelem"><a href="../../da/d10/libtut_lat.html">LatBuilder tutorial</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for LatNet Builder Manual by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
