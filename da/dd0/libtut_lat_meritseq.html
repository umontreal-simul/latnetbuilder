<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: Sequences of Merit Values</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatNet Builder Manual<span id="projectnumber">&#160;2.1.3-6</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('da/dd0/libtut_lat_meritseq.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sequences of Merit Values </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Iterating through a sequence of lattice definitions and evaluating a figure of merit for each element, as in <a class="el" href="../../df/d4b/libtut_lat_figures.html">Weighted Figures of Merit</a>, is a common task when searching for good lattice parameters. LatBuilder abstracts out this process by providing sequences of (computed) merit values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html" title="Sequences of merit values.">MeritSeq</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_meritseq_cbc_simple"></a>
CBC Construction</h1>
<p>The example in <a class="el" href="../../d1/d06/tutorial_2MeritSeqCBC_8cc-example.html">tutorial/MeritSeqCBC.cc</a> improves on the example from <a class="el" href="../../df/d4b/libtut_lat_figures.html#libtut_lat_figures_cbc_simple">A Simple Example Using CBC Construction</a>.</p>
<p>The base lattice and its merit value are managed by <a class="el" href="../../d5/dd2/classLatBuilder_1_1MeritSeq_1_1CBC.html" title="Sequence of lattice merit for CBC exploration.">MeritSeq::CBC</a>, so we can remove the declarations of <code>baseLat</code> and <code>initialMerit</code>, and introduce: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a> = <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#a85b95dfef3ffbb2765f918552aee96f0">MeritSeq::cbc</a>(storage, figure);</div>
</div><!-- fragment --><p> In the CBC loop, we instantiate the sequence of merit values with: </p><div class="fragment"><div class="line">      <span class="keyword">auto</span> meritSeq = <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a>.meritSeq(baseDim == 0 ? genSeq0 : genSeq);</div>
</div><!-- fragment --><p> Because the elements of <code>meritSeq</code> are of the abstract type <a class="el" href="../../d8/d18/structLatBuilder_1_1MeritFilterTraits.html">MeritValue</a>, we need to convert them to the <a class="el" href="../../d1/d74/namespaceLatBuilder.html#acaaada8fcc395f28434f8a32a97b03ca" title="Scalar floating-point type.">Real</a> type using an empty list of merit value filters declared as: </p><div class="fragment"><div class="line">   <a class="code hl_class" href="../../dd/d23/classLatBuilder_1_1MeritFilterList.html">MeritFilterList&lt;LA, L&gt;</a> filters;</div>
</div><!-- fragment --><p> and applied with: </p><div class="fragment"><div class="line">      <span class="keyword">auto</span> filteredSeq = filters.<a class="code hl_function" href="../../dd/d23/classLatBuilder_1_1MeritFilterList.html#a2821a7911e9a502455db82c494e7b5ab">apply</a>(meritSeq);</div>
</div><!-- fragment --><p> Such a filter list can also be used to combine the merit values of individual levels in the case of embedded lattices (see <a class="el" href="../../dd/dd9/libtut_lat_filters.html">Filters and Combiners</a>). Then, we replace the minimization loop with a call to std::min_element: </p><div class="fragment"><div class="line">      <span class="keyword">auto</span> best = std::min_element(filteredSeq.begin(), filteredSeq.end());</div>
</div><!-- fragment --><p> and notify the CBC instance that we have found our best lattice for the current dimension: </p><div class="fragment"><div class="line">      <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a>.select(best.base());</div>
</div><!-- fragment --><p> Here, <code>best</code> is an iterator on the <code>filteredSeq</code> sequence, and <code>best.base()</code> is an iterator on corresponding element of the underlying <code>meritSeq</code> sequence. The output of this example is: </p><pre class="fragment">figure of merit: Projection Dependent Merit: spectral^1 (symmetric) - Accumulator: Max
Norm Type: 2
Weights: ProductWeights([], default=0.7)
CBC search for dimension: 1
base lattice: 
Ordinary Lattice - Modulus = 256 - Generating vector = []
base merit value: 0
new projections: [{0}]
BEST LATTICE: 
Ordinary Lattice - Modulus = 256 - Generating vector = [1]
Merit value: 0.7
CBC search for dimension: 2
base lattice: 
Ordinary Lattice - Modulus = 256 - Generating vector = [1]
base merit value: 0.7
new projections: [{1}, {0,1}]
BEST LATTICE: 
Ordinary Lattice - Modulus = 256 - Generating vector = [1, 15]
Merit value: 0.7
CBC search for dimension: 3
base lattice: 
Ordinary Lattice - Modulus = 256 - Generating vector = [1, 15]
base merit value: 0.7
new projections: [{2}, {0,2}, {1,2}, {0,1,2}]
BEST LATTICE: 
Ordinary Lattice - Modulus = 256 - Generating vector = [1, 15, 39]
Merit value: 0.746627
</pre><h1 class="doxsection"><a class="anchor" id="libtut_lat_meritseq_cbc_signals"></a>
CBC Construction Using Signals</h1>
<p>To improve on the above example by using signals, we can reintroduce the <code>Observer</code> class from <a class="el" href="../../df/d4b/libtut_lat_figures.html#libtut_lat_figures_signals">A Improved Example Using Signals</a>. We also need to notify the <code>Observer</code> class when a new minimum value is updated, with a few changes: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;LatticeType LA&gt;</div>
<div class="line"><span class="keyword">class </span>Observer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   <span class="keyword">typedef</span> LatBuilder::LatDef&lt;LA, EmbeddingType::UNILEVEL&gt; LatDef;</div>
<div class="line"> </div>
<div class="line">   Observer() { reset(); }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// initializes the best observed merit value to infinity</span></div>
<div class="line">   <span class="keywordtype">void</span> reset() { m_bestMerit = std::numeric_limits&lt;Real&gt;::infinity(); }</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">bool</span> onProgress(Real merit)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ <span class="keywordflow">return</span> merit &lt;= m_bestMerit; }</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">void</span> onAbort(<span class="keyword">const</span> LatDef&amp; lat)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">   </span>{ std::cout &lt;&lt; <span class="stringliteral">&quot;rejected:&quot;</span> &lt;&lt; std::endl &lt;&lt; lat; }</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">void</span> onMinUpdated(<span class="keyword">const</span> Real&amp; bestMerit)</div>
<div class="line">   { m_bestMerit = bestMerit; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">   <a class="code hl_typedef" href="../../d1/d74/namespaceLatBuilder.html#acaaada8fcc395f28434f8a32a97b03ca">Real</a> m_bestMerit;</div>
<div class="line">};</div>
</div><!-- fragment --><p> So, instead of using <code>std::min_element</code>, we use <a class="el" href="../../d2/d79/structLatBuilder_1_1Functor_1_1MinElement.html" title="Minimum element functor.">Functor::MinElement</a> and connect its <a class="el" href="../../d2/d79/structLatBuilder_1_1Functor_1_1MinElement.html#a0a323fa1838890ceea1eea71137c2363" title="Minimum-updated signal.">Functor::MinElement::onMinUpdated()</a> signal to <code>Observer::onMinUpdated()</code>: </p><div class="fragment"><div class="line">   <a class="code hl_struct" href="../../d2/d79/structLatBuilder_1_1Functor_1_1MinElement.html">Functor::MinElement&lt;Real&gt;</a> minElement;</div>
<div class="line">   minElement.<a class="code hl_function" href="../../d2/d79/structLatBuilder_1_1Functor_1_1MinElement.html#a0a323fa1838890ceea1eea71137c2363">onMinUpdated</a>().connect(boost::bind(&amp;Observer&lt;LA&gt;::onMinUpdated, &amp;obs, _1));</div>
</div><!-- fragment --><p> Then replace the call to <code>std::min_element()</code> with: </p><div class="fragment"><div class="line">      obs.reset();</div>
<div class="line">      <span class="keyword">auto</span> best = minElement(filteredSeq.begin(), filteredSeq.end(), 0);</div>
</div><!-- fragment --><p> Also note the call to <code>Observer::reset()</code> to initialize the best observed merit value before using <code>minElement</code>. The resulting code can be found in <a class="el" href="../../d9/dd5/tutorial_2MeritSeqCBCSignals_8cc-example.html">tutorial/MeritSeqCBCSignals.cc</a> .</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_meritseq_coorduni"></a>
CBC Construction for Coordinate-Uniform Figures of Merit</h1>
<p>Figures of merit in a coordinate-uniform form can be evaluated more efficiently than the general weighted figures of merit. Here, we consider the case of the weighted \(\mathcal P_\alpha\) discrepancy for ordinary lattices, and the case of the weighted \(\mathcal P_{\alpha,PLR}\) for polynomial lattices. by adapting the code from <a class="el" href="#libtut_lat_meritseq_cbc_simple">CBC Construction</a> . First, we replace the <a class="el" href="../../d8/dca/classLatBuilder_1_1WeightedFigureOfMerit.html" title="Weighted figure of merit.">WeightedFigureOfMerit</a> instance with an instance of <a class="el" href="../../d8/dfb/classLatBuilder_1_1CoordUniformFigureOfMerit.html" title="Base base class for coordinate-uniform figures of merit.">CoordUniformFigureOfMerit</a>: For ordinary lattices: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> weights = unique&lt;LatticeTester::ProductWeights&gt;();</div>
<div class="line">   weights-&gt;setDefaultWeight(0.7);</div>
<div class="line"> </div>
<div class="line">   <a class="code hl_class" href="../../d8/dfb/classLatBuilder_1_1CoordUniformFigureOfMerit.html">CoordUniformFigureOfMerit&lt;Kernel::PAlpha&gt;</a> figure(std::move(weights), 2);</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;figure of merit: &quot;</span> &lt;&lt; figure &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> For polynomial lattices: </p><div class="fragment"><div class="line">   auto weights = unique&lt;LatticeTester::ProductWeights&gt;();</div>
<div class="line">   weights-&gt;setDefaultWeight(0.7);</div>
<div class="line"> </div>
<div class="line">   CoordUniformFigureOfMerit&lt;Kernel::PAlphaTilde&gt; figure(std::move(weights), 2);</div>
<div class="line">   std::cout &lt;&lt; &quot;figure of merit: &quot; &lt;&lt; figure &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The type of weights must be specified as a template argument because a different evaluation algorithm is used for different types of weights. Then, we replace the <a class="el" href="../../d5/dd2/classLatBuilder_1_1MeritSeq_1_1CBC.html" title="Sequence of lattice merit for CBC exploration.">MeritSeq::CBC</a> instance with a <a class="el" href="../../d3/d0c/classLatBuilder_1_1MeritSeq_1_1CoordUniformCBC.html" title="Sequence of lattice merit for weighted coordinate-uniform figures of merit.">MeritSeq::CoordUniformCBC</a> instance: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a> = <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#a85b95dfef3ffbb2765f918552aee96f0">MeritSeq::cbc&lt;MeritSeq::CoordUniformInnerProd&gt;</a>(storage, figure);</div>
</div><!-- fragment --><p> The <a class="el" href="../../df/df8/classLatBuilder_1_1MeritSeq_1_1CoordUniformInnerProd.html" title="Standard implementation of the inner product for a sequence of vector with a single vector.">MeritSeq::CoordUniformInnerProd</a> template argument specifies that we want to use a standard inner product during CBC exploration. The complete example can be found in <a class="el" href="../../d0/d78/tutorial_2MeritSeqCoordUniform_8cc-example.html">tutorial/MeritSeqCoordUniform.cc</a>.</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_meritseq_fastcbc"></a>
Fast CBC Construction</h1>
<p>Here, we modify the example from <a class="el" href="#libtut_lat_meritseq_coorduni">CBC Construction for Coordinate-Uniform Figures of Merit</a> in order to use the fast CBC method, which is implemented only with coordinate-uniform figures of merit. First, we need to replace <a class="el" href="../../df/df8/classLatBuilder_1_1MeritSeq_1_1CoordUniformInnerProd.html" title="Standard implementation of the inner product for a sequence of vector with a single vector.">MeritSeq::CoordUniformInnerProd</a> with <a class="el" href="../../d6/d19/classLatBuilder_1_1MeritSeq_1_1CoordUniformInnerProdFast.html" title="FFT-based implementation of the inner product for a circulant sequence of vector with a single vector...">MeritSeq::CoordUniformInnerProdFast</a>: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a> = <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#a85b95dfef3ffbb2765f918552aee96f0">MeritSeq::cbc&lt;MeritSeq::CoordUniformInnerProdFast&gt;</a>(storage, figure);</div>
</div><!-- fragment --><p> The fast CBC algorithm requires a special ordering of the generator values, so we also need to replace: </p><div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d36/classLatBuilder_1_1GenSeq_1_1GeneratingValues.html">GenSeq::GeneratingValues</a>&lt;LA, <span class="keyword">decltype</span>(figure)::suggestedCompression()&gt; Coprime;</div>
</div><!-- fragment --><p> with: </p><div class="fragment"><div class="line">   <span class="keyword">typedef</span> <a class="code hl_class" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html">GenSeq::CyclicGroup</a>&lt;LA, <span class="keyword">decltype</span>(figure)::suggestedCompression()&gt; Coprime;</div>
</div><!-- fragment --><p> Note that instantiating <a class="el" href="../../da/d17/classLatBuilder_1_1GenSeq_1_1CyclicGroup.html" title="Cyclic group.">GenSeq::CyclicGroup</a> requires the number of points to be an integer power of a prime base. Then, we modify the instantiation of <code>meritSeq</code> accordingly: </p><div class="fragment"><div class="line">      <span class="keyword">auto</span> meritSeq = <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#acc3d359944b843510407dda3bba516f5">cbc</a>.meritSeq(baseDim == 0 ? genSeq0 : genSeq);</div>
</div><!-- fragment --><p> The complete example can be found in <a class="el" href="../../d9/d08/tutorial_2MeritSeqFastCBC_8cc-example.html">tutorial/MeritSeqFastCBC.cc</a>.</p>
<h1 class="doxsection"><a class="anchor" id="libtut_lat_meritseq_noncbc"></a>
Non-CBC Construction Methods</h1>
<p>In LatBuilder, sequences of merit values for non-CBC exploration methods are available only as a wrapper of the CBC exploration applied independently to each lattice definition, by replacing the sequences of candidate lattice definitions by singletons that contain only the candidate lattice being currently examined. CBC exploration can thus output only this one lattice, together with its merit value. This enables the efficient computation algorithms used in the coordinate-uniform case with standard CBC.</p>
<p>The example in <a class="el" href="../../d8/df8/tutorial_2MeritSeqNonCBC_8cc-example.html">tutorial/MeritSeqNonCBC.cc</a> illustrates how to transform the CBC search from <a class="el" href="#libtut_lat_meritseq_coorduni">CBC Construction for Coordinate-Uniform Figures of Merit</a> into a Korobov search. First, we create an instance of <a class="el" href="../../d1/db6/classLatBuilder_1_1MeritSeq_1_1LatSeqOverCBC.html" title="Sequence of merit values for any sequence of lattice definitions.">MeritSeq::LatSeqOverCBC</a> and a sequence of Korobov lattice definitions: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#abfd3ddf15dd2df572ea8fd7cf93296bf">latSeqOverCBC</a> = <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#abfd3ddf15dd2df572ea8fd7cf93296bf">MeritSeq::latSeqOverCBC</a>(cbc);</div>
<div class="line">   <span class="keyword">auto</span> latSeq = <a class="code hl_function" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html#a977b8ae778654cfa312be6f98197564b">LatSeq::korobov</a>(storage.sizeParam(), Coprime(storage.sizeParam().modulus()), dimension);</div>
</div><!-- fragment --><p> Then, the whole CBC loop is replaced with the execution of the Korobov search: </p><div class="fragment"><div class="line">   <span class="keyword">auto</span> meritSeq = <a class="code hl_function" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html#abfd3ddf15dd2df572ea8fd7cf93296bf">latSeqOverCBC</a>.meritSeq(latSeq);</div>
<div class="line">   <span class="keyword">auto</span> filteredSeq = filters.<a class="code hl_function" href="../../dd/d23/classLatBuilder_1_1MeritFilterList.html#a2821a7911e9a502455db82c494e7b5ab">apply</a>(meritSeq);</div>
<div class="line">   <span class="keyword">auto</span> best = std::min_element(filteredSeq.begin(), filteredSeq.end());</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;BEST LATTICE: &quot;</span> &lt;&lt; std::endl &lt;&lt; *best.base().base() &lt;&lt; <span class="stringliteral">&quot;Merit value: &quot;</span> &lt;&lt; *best &lt;&lt; std::endl;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../index.html">LatNet Builder Manual</a></li><li class="navelem"><a href="../../da/d6f/libtut.html">Library Tutorial</a></li><li class="navelem"><a href="../../da/d10/libtut_lat.html">LatBuilder tutorial</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for LatNet Builder Manual by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
