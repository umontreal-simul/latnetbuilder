<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: Quick Recipes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatNet Builder Manual<span id="projectnumber">&#160;2.1.3-6</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d0/da5/cmdtut_quickrecipes.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Quick Recipes </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_first_example"></a>
A first example</h1>
<p>In this section, we start with a basic example to perform a standard component-by-component (CBC) method for an ordinary lattice rule, which we use to introduce the different command-line options. After, we extend that example in various ways to show how to achieve more elaborated tasks.</p>
<p>Consider the following basic example: </p><pre class="fragment">latnetbuilder \ 
 --set-type lattice \
 --construction ordinary \
 --size 2053 \
 --dimension 5 \
 --exploration-method full-CBC  \
 --figure-of-merit CU:P2 \
 --norm-type 2 \
 --weights product:0.7
</pre><p>The order in which the arguments are specified is not important. Some arguments consists of several tokens, separated by a colon.</p>
<ul>
<li>The argument <code>&ndash;set-type lattice </code> indicates that we seek a rank-1 lattice rule.</li>
<li>The argument <code>--construction ordinary</code> indicates that we seek an ordinary (in contrast to polynomial) rank-1 lattice rule.</li>
<li>The argument <code>--size 2053</code> indicates that we seek a lattice rule with modulus 2053.</li>
<li>The argument <code>--dimension 5</code> specifies that we seek a lattice point set of dimension 5.</li>
<li>The argument <code>--exploration-method full-CBC</code> specifies that the CBC method should be used.</li>
<li>The argument <code>--figure-of-merit CU:P2</code> consists of two colon-separated tokens. It tells LatNet Builder to use the specialized coordinate-uniform evaluation algorithm, whence the first <code>CU</code> token, for the \(\mathcal P_2\) discrepancy.</li>
<li>The argument <code>&ndash;norm-type 2</code> indicates that the \(\ell_2\) norm is used to accumulate the merit of all projections. As we are using the \(\mathcal P_2\) discrepancy with the coordinate-uniform evaluation algorithm, this is the only possible norm.</li>
<li>The argument <code>--weights product:0.7</code> assigns product weights to the figure of merit, with the same weight (0.7) for every coordinate.</li>
</ul>
<p>To summarize, this command executes a CBC method for an ordinary lattice rule with 2053 points in 5 dimensions, using the weighted \(\mathcal P_2\) figure of merit with an \(\ell_2\) norm and product weights such that \(\gamma_j^2 = 0.7\) for all \(j\). The evaluation uses the coordinate-uniform algorithm.</p>
<p>Option names come in long and short forms. For example, the following has the same effect as the previous example: </p><pre class="fragment">latnetbuilder -t lattice -c ordinary -s 2053 -d 5 -e full-CBC -f CU:P2 -q 2 -w product:0.7
</pre><p> The long forms are favored in this tutorial to make the examples self-explanatory.</p>
<p>For the sake of conciseness, in the derived examples, we often only show the command-line parameters that need to be changed, or added; other parameters should be left as in the basic example.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_outputfolder"></a>
Saving the results in a folder</h1>
<p>It is possible to save the results of LatNet Builder in a folder. The <code>&ndash;output-folder</code> option indicates the path of the folder to use. This path can either be absolute or relative. If the folder does not exist, it will be created. <b>If the folder already exists, some existing files may be lost.</b> For instance, if you want the output folder to be located at <code>/home/results</code>, use <code> &ndash;output-folder /home/results </code></p>
<p>This folder contains two files:</p><ul>
<li><code>input.txt</code> which contains the summary of the input parameters of LatNet Builder</li>
<li><code>output.txt</code> which contains an easily parsable formatting of the results</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_explorations"></a>
Exploring the search space with other methods</h1>
<p>LatNet Builder supports a variety of exploration methods. The <code>&ndash;exploration-method</code> option controls which one is used to explore the search space.</p>
<p>To fasten computation, it is recommended to use the fast-CBC algorithm instead of full-CBC whenever possible. This is done by using the following option:</p>
<p><code>&ndash;exploration-method fast-CBC</code>.</p>
<p>Using the fast-CBC method does not really change the exploration method but reduces the computation time. However, other methods, such as the random exploration method, are really different. For instance, to select the best point set among 100 random point sets, one can use the following option:</p>
<p><code>&ndash;exploration-method random:100</code>.</p>
<p>All the available exploration methods and the usage restrictions can be found <a class="el" href="../../d3/d28/cmdtut_advanced_exploration.html">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_figures"></a>
Using different figures of merit</h1>
<p><a class="el" href="../../d6/d4c/feats_figures.html">Figures of merit</a> are constructed using the following ingredients:</p><ul>
<li>a projection-dependent merit \(D_{\mathfrak u}\);</li>
<li>weights \(\gamma_{\mathfrak u}\); and</li>
<li>a norm-type \(\ell_q\).</li>
</ul>
<p>By changing the value of the options corresponding to these three ingredients, one can explore the various figures of merit which are supported by LatNet Builder.</p>
<p>To use another projection-dependent merit than the \(\mathcal P_2\) discrepancy, one should change the value of the <code>&ndash;figure-of-merit</code> option. For instance, to use the \(\mathcal R_1\) criterion, with the coordinate-uniform evaluation algorithm, the following option should be used:</p>
<p><code>&ndash;figure-of-merit CU:R1</code></p>
<p>The different projection-dependent merits which are available and their usage restrictions are listed <a class="el" href="../../d3/d8e/cmdtut_advanced_figures.html">here</a>.</p>
<p>Alternatively, one can change the type of weights. This can be done by changing the value of the <code>&ndash;weights</code> option. For instance:</p>
<p><code>&ndash;weights order-dependent:1</code></p>
<p>will tell LatNet Builder to use weights equal to 1 for all projections. Details on the possible value for the <code>&ndash;weights</code> option can be found <a class="el" href="../../df/d36/cmdtut_advanced_weights.html">here</a>.</p>
<p>Finally, the \(\ell_2\) norm can be replaced by another norm. For instance to use the \(\mathcal P_2\) discrepancy will an \(\ell_3\) norm, use the following options:</p>
<p><code>&ndash;figure-of-merit P2 &ndash;norm-type 3</code>.</p>
<p>Note that the <code>CU</code> token has disappeared: only a specific norm-type is compatible with the coordinate-uniform evaluation algorithm. Consequently, changing the norm-type will often lead to longer computations.</p>
<p>One can also use the \(\ell_\infty\) norm, for instance with the spectral projection-dependent merit:</p>
<p><code>&ndash;figure-of-merit spectral &ndash;norm-type inf</code>.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_pointsets"></a>
Constructing polynomial lattice rules and digital nets</h1>
<p>As explained <a class="el" href="../../d6/d4c/feats_figures.html">here</a>, the available figures of merit depend on the type of the point set we want to construct. Now that we know how to change the figure of merit, we can construct digital nets and polynomial lattice rules.</p>
<p>Let's start with digital nets. Say we want to construct a digital net with random generating matrices and that we want the digital net to have \(2^{10}\) points. We will look at the best net among a hundred nets.</p>
<p>Then the following options should be used:</p>
<p><code>&ndash;set-type net &ndash;construction explicit &ndash;size 2^10 &ndash;random:100</code>.</p>
<p>We now need a figure of merit to evaluate the net. We can for instance use the maximum of the t-value of the subprojections of order lower than 3:</p>
<p><code>&ndash;figure-of-merit projdep:t-value &ndash;norm-type inf &ndash;weights order-dependent:0:1,1,1</code>.</p>
<p>Again the possible figures of merit are listed <a class="el" href="../../d3/d8e/cmdtut_advanced_figures.html">here</a>. It is really easy to use the Sobol' construction instead of random matrices. You just have to change <code>&ndash;construction explicit</code> to <code>&ndash;construction sobol</code>.</p>
<p>Polynomial lattice rules are a bit trickier because they can be constructed either with <code>&ndash;set-type lattice &ndash;construction polynomial</code> or <code>&ndash;set-type net &ndash;construction polynomial</code>. There is a huge performance gap between these two approaches depending on what you precisely want to do. Happily, <a class="el" href="../../da/d25/feats_poly.html">detailed guidelines</a> are available for you to pull through. But here we will just compare the two following examples:</p>
<pre class="fragment">latnetbuilder \ 
 --set-type lattice \
 --construction polynomial \
 --size 2^10 \
 --dimension 5 \
 --exploration-method fast-CBC  \
 --figure-of-merit CU:R \
 --norm-type 2 \
 --weights product:0.7
</pre><pre class="fragment">latnetbuilder \ 
 --set-type net \
 --construction polynomial \
 --size 2^10 \
 --dimension 5 \
 --exploration-method random-CBC:70  \
 --figure-of-merit CU:R \
 --norm-type 2 \
 --weights product:0.7
</pre><p>The only difference between these two examples it that the first performs a fast-CBC exploration with the \(\mathcal R\) criterion (note the <code>CU</code> token) whereas the second uses a random-CBC exploration with 70 samples per coordinate. For now, just retain the general idea that that the lattice approach (first example) should only be used with the fast-CBC construction. In all the other cases, the net approach (second example) is most efficient.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_filters"></a>
Applying filters and normalizations</h1>
<p>The general idea behind filters and normalizations is explained <a class="el" href="../../d9/d80/feats_filters.html">here</a>. Filters are optional and can be used to transform the computed values of a figure of merit, or to reject bad values. Multiple filters can be chained together by specifying multiple filter arguments separated by whitespace.</p>
<ul>
<li>Normalization using a bound on \(\mathcal P_\alpha\) from <a class="el" href="../../d0/de3/citelist.html#CITEREF_rsin11a">[29]</a> with \(\alpha=2\): <pre class="fragment">    --filters norm:P2-SL10
</pre> The first colon-separated token (<code>norm</code>) indicates that we want to apply a normalization. The second one is the type of normalization (here, a particular bound on \(\mathcal P_2\).</li>
<li>Rejecting candidate lattices that have a normalized merit value larger than unity: <pre class="fragment">    --filters norm:P2-SL10 low-pass:1.0
</pre> The first filter is explained above. The second filter consists of two colon-separated tokens: the first one (<code>low-pass</code>) indicates that we want to apply a low-pass filter on merit values; the second one specifies the threshold value of this low-pass filter.</li>
</ul>
<p>For usage with embedded lattices, see <a class="el" href="#cmdtut_quickrecipes_embedded">Constructing embedded point sets</a>. Additional details on how to use filters and normalizations can be found <a class="el" href="../../d2/d15/cmdtut_advanced_filters.html">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_embedded"></a>
Constructing embedded point sets</h1>
<p>For <a class="el" href="../../d6/d6f/feats_multilevel.html">multilevel point sets</a>, a merit value is computed for each embedding level. Optionally, <a class="el" href="../../d9/d80/feats_filters.html#feats_filters_multilevel">multilevel filters and normalizations</a> are applied to the merit value of each level. Then the merits are combined using a sum or a maximum.</p>
<p>Let us start by giving an example with the Sobol' construction. We search for a multilevel digital net in dimension 7 with \(2^{15}\) points for the maximum embedding level. We will use the projection-dependent t-value-based star discrepancy bound merit, with an \(\ell_{\infty}\) norm and order-dependent weights equal to 0.9 on the 2-dimensional projections, 0.3 on the three-dimensional projections and 0.2 on the four-dimensional projections. To combine the merit values, we will use the maximum, which is more compatible with the star discrepancy (which is itself a maximum) than a sum. The search will be based on the full-CBC exploration method. </p><pre class="fragment">latnetbuilder \
--set-type net \
--construction sobol \
--size 2^15 \
--dimension 7 \
--exploration-method full-CBC  \
--figure-of-merit projdep:t-value:starDisc \
--norm-type inf \
--weights order-dependent:0:0,.9,.3,.2 \
--multilevel true \
--combiner max
</pre><p>Note the <code>&ndash;multilevel true</code> option: it tells LatNet Builder that we search for an embedded point set. The combiner is specified with the <code>&ndash;combiner</code> option. All the possible values for this option are listed <a class="el" href="../../df/df1/cmdtut_advanced_multilevel.html">here</a>.</p>
<p>Now we give another example for embedded ordinary lattice rules with a <a class="el" href="../../d9/d80/feats_filters.html#feats_filters_multilevel">multilevel normalization</a>. We search for an embedded lattice rule in dimension 10, with \(2^{17}\) points. We use the \(\mathcal P_2\) discrepancy with an \(\ell_2\) norm, enabling the coordinate-uniform evaluation algorithm. The weights are order-dependent weights. The combiner is a sum. We use the fast-CBC algorithm to fasten the computations. We add the <a class="el" href="../../d9/d80/feats_filters.html#norm_SL10">SL10 normalization</a> (<code>&ndash;filters norm:P2-SL10:select:10,17</code>). <br  />
 Note the <code>select:10,17</code> token which tells LatNet Builder to put positive weights for the embedding levels 10 to 17, and a zero weight for the other embedding level.</p>
<pre class="fragment">latnetbuilder \
--set-type lattice \
--construction ordinary \
--size 2^17 \
--dimension 10 \
--exploration-method fast-CBC  \
--figure-of-merit CU:P2 \
--norm-type 2 \
--weights order-dependent:.1:0,.8,.3,.2 \
--multilevel true \
--combiner sum \
--filters norm:P2-SL10:select:10,17
</pre><h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_eval"></a>
Evaluating figures of merit for a specific point set</h1>
<p>In this section we focus on the evaluation of a figure of merit for a specific point set. Evaluation is not a real exploration method as the search space is limited to only one point set. It is meant to compute the quality of only one point set.</p>
<p>First, we must be able to tell LatNet Builder which point set we want to evaluate. We will just give an example for ordinary lattice rules.</p>
<p>Say we want to evaluate the \(\mathcal R_1\) criterion with product weights equal to 0.9 and an \(\ell_2\) norm for the lattice rule with modulus 11551 and generating vector (1, 5396, 2285, 484, 5355, 20, 249, 4237, 4919, 3622). The following command-line will do the job: </p><pre class="fragment">latnetbuilder \
--set-type lattice \
--construction ordinary \
--size 11551 \
--dimension 10 \
--exploration-method evaluation:1-5396-2285-484-5355-20-249-4237-4919-3622  \
--figure-of-merit CU:R1 \
--norm-type 2 \
--weights product:.9
</pre><p>The way we specify the other point set types is explained <a class="el" href="../../d2/d6f/cmdtut_advanced_pointsets.html">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_interlaced"></a>
Constructing interlaced digital nets and polynomial lattice rules</h1>
<p>In this section, we explain how to construct good <a class="el" href="../../dc/d5a/feats_pointsets.html#feats_pointsets_interlaced">interlaced polynomial lattice rules</a>. <a class="el" href="../../d3/dc5/feats_figures_lat.html#feats_figures_lat_interlaced">Specific figures of merit</a> must be used for interlaced polynomial lattice rules. One must also choose an interlacing factor, which equals the number of interlaced components used for each coordinate.</p>
<p>Say we want to construct an interlaced polynomial lattice rules in dimension 10 with \(2^{15}\) points and an interlacing factor \(d\) equal to 2. We will use the \(B_{d,(2)}\) interlaced discrepancy with the \(\ell_1\) norm to enable the coordinate-uniform evaluation algorithm and the fast-CBC method. The weights will be product weights equal to \(.9\).</p>
<pre class="fragment">latnetbuilder \
--set-type lattice \
--construction polynomial \
--size 2^15 \
--dimension 10 \
--exploration-method fast-CBC  \
--figure-of-merit CU:IB \
--norm-type 1 \
--weights product:.9 \
--interlacing-factor 2
</pre><ul>
<li>the <code>&ndash;figure-of-merit CU:IB</code> option tells LatNet Builder that we want to use the \(B_{d,(2)}\) interlaced discrepancy;</li>
<li>the <code>interlacing-factor 2</code> option tells LatNet Builder that \(d=2\).</li>
</ul>
<p>LatNet Builder will actually search for the best underlying polynomial lattice rule, that is the polynomial lattice rules in dimension 20 which gives the best interlaced polynomial lattice rule in dimension 10.</p>
<p>You can fin additional details on constructing interlaced digital nets and polynomial lattice rules <a class="el" href="../../d6/d9e/cmdtut_advanced_interlaced.html">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="cmdtut_quickrecipes_extend"></a>
Extending point sets</h1>
<p>Suppose you have constructed embedded lattice rules up to \(2^8\) points in dimension 5 with: </p><pre class="fragment">latnetbuilder \
  --set-type lattice \
  --construction ordinary \
  --size 2^8 \
  --dimension 5 \
  --exploration-method fast-CBC \
  --figure-of-merit CU:P2 \
  --norm-type 2 \
  --weights product:0.1 \
  --multilevel true \
  --combiner sum \
  --filters norm:P2 low-pass:1.0
</pre><p> and have obtained the generating vector \(\boldsymbol a=(1,45,101,41,25)\). Then, you find out that you need to extend the number of points to \(2^9\). This can be done with: </p><pre class="fragment">latnetbuilder \
  --set-type lattice \
  --construction ordinary \
  --size 2^9 \
  --dimension 5 \
  --exploration-method extend:2^8:1-45-101-41-25 \
  --figure-of-merit CU:P2 \
  --norm-type 2 \
  --weights product:0.1
</pre><p> Note that only the merit value of the lattice with \(2^9\) points, and not that of the embedded lattices, is considered in this type of construction. The argument <code>--size 2^9</code> specifies the extended number of points and the argument <code>--exploration-method extend:2^8:1-45-101-41-25</code> indicates that we want to extend on a lattice with \(2^8\) points and generating vector \(\boldsymbol a=(1,45,101,41,25)\).</p>
<p>It is also possible to extend polynomial lattice rules in a similar manner. See <a class="el" href="../../d2/d6f/cmdtut_advanced_pointsets.html">here</a> to learn how to specify a generating vector for a polynomial lattice rule. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../index.html">LatNet Builder Manual</a></li><li class="navelem"><a href="../../d5/d56/cmdtut.html">Command-Line Tutorial</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for LatNet Builder Manual by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
