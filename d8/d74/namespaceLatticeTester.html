<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LatNet Builder Manual<span id="projectnumber">&#160;2.1.3-6</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">LatticeTester Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lattice namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace containing different implementation of sets of coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfe/namespaceLatticeTester_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:d3/dfe/namespaceLatticeTester_1_1Random"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html">BasisConstruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements general methods to perform a lattice basis construction from a set of vectors, as well as general methods to obtain the dual lattice basis depending on the current lattice basis.  <a href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dcd/classLatticeTester_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a configuration that can be passed to a <code><a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html" title="Objects of this class can perform various tests on lattices.">LatticeAnalysis</a></code> object to perform a computation.  <a href="../../d8/dcd/classLatticeTester_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a <code>std::set&lt;std::size_t&gt;</code>.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d95/classLatticeTester_1_1IntFactor.html">IntFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects of this class are the "prime" factors in the decomposition of a positive integer.  <a href="../../d6/d95/classLatticeTester_1_1IntFactor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a skeleton for the implementation of different types of lattices.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a lattice and its basis and offers tools to do basic manipulations on lattice bases.  <a href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html">Lacunary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a set of indices with lacunary values.  <a href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html">LatticeAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects of this class can perform various tests on lattices.  <a href="../../df/d59/classLatticeTester_1_1LatticeAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d89/structLatticeTester_1_1LLLConstr.html">LLLConstr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de5/classLatticeTester_1_1NormaBestBound.html">NormaBestBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../df/de5/classLatticeTester_1_1NormaBestBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which inherit from this base class are used in implementing bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html">NormaMinkL1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the length of the shortest nonzero vector in a lattice, based on the densest sphere packing in space.  <a href="../../d8/d4c/classLatticeTester_1_1NormaMinkL1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html">NormaMinkowski</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements Minkowski’s theoretical <b>LOWER</b> bound on the length of the shortest non-zero vector in a lattice.  <a href="../../d9/d36/classLatticeTester_1_1NormaMinkowski.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the lenght of the shortest nonzero vector in a lattice.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html">OrderDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order-dependent weights.  <a href="../../d3/d01/classLatticeTester_1_1OrderDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that can be used to read different kind of data from a file.  <a href="../../da/d47/classLatticeTester_1_1ParamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de7/classLatticeTester_1_1PODWeights.html">PODWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product and order-dependent (POD) weights.  <a href="../../d4/de7/classLatticeTester_1_1PODWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html">ProductWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product weights.  <a href="../../da/d3e/classLatticeTester_1_1ProductWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection-dependent weights.  <a href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a general rank 1 lattice.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements (or wraps from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a>) all the functions that are needed to reduce a basis.  <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html">Types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets standard <code>typedef</code>’s for the types that can be used in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a>.  <a href="../../d6/df9/classLatticeTester_1_1Types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/classLatticeTester_1_1UniformWeights.html">UniformWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement the same weight for all projections.  <a href="../../d7/d89/classLatticeTester_1_1UniformWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class representing <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class representing Weights for figures of merit.">Weights</a> for figures of merit.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html">Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract class that represents an interface to <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes.">Writer</a></code> classes.  <a href="../../d4/dc5/classLatticeTester_1_1Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d30/classLatticeTester_1_1WriterRes.html">WriterRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple implementation of the <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes.">Writer</a></code> abstract class to write in plain text format on the stream.  <a href="../../d2/d30/classLatticeTester_1_1WriterRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4" id="r_a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> { <b>SUPNORM</b> = 1
, <b>L1NORM</b> = 2
, <b>L2NORM</b> = 3
, <b>ZAREMBANORM</b> = 4
 }</td></tr>
<tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which norm is used to measure the length of vectors.  <a href="#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058" id="r_ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a> { <b>TERM</b>
, <b>RES</b>
, <b>TEX</b>
, <b>GEN</b>
 }</td></tr>
<tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which form and where the results will be sent.  <a href="#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b917d5ef7e8167bc50aa56109faff" id="r_aad7b917d5ef7e8167bc50aa56109faff"><td class="memItemLeft" align="right" valign="top"><a id="aad7b917d5ef7e8167bc50aa56109faff" name="aad7b917d5ef7e8167bc50aa56109faff"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a> { <br />
&#160;&#160;<b>BASIS</b>
, <b>DUAL</b>
, <b>REDUCTION</b>
, <b>SHORTEST</b>
, <br />
&#160;&#160;<b>MERIT</b>
<br />
 }</td></tr>
<tr class="memdesc:aad7b917d5ef7e8167bc50aa56109faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum listing the problems that <a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a> can solve. <br /></td></tr>
<tr class="separator:aad7b917d5ef7e8167bc50aa56109faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2" id="r_a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top"><a id="a94f96ff406f8b56147a2b7fd96209cb2" name="a94f96ff406f8b56147a2b7fd96209cb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> { <br />
&#160;&#160;<b>DOUBLE</b>
, <b>QUADRUPLE</b>
, <b>EXPONENT</b>
, <b>ARBITRARY</b>
, <br />
&#160;&#160;<b>EXACT</b>
<br />
 }</td></tr>
<tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates in which precision the <a class="el" href="d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> algorithms will be perfoms : <code>DOUBLE</code> &ndash; double <code>QUADRUPLE</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>EXPONENT</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>ARBITRARY</code> &ndash; RR (arbitrary precision floating point) this is useful for large precision and magnitudes Generally speaking, the choice <code>DOUBLE</code> will be the fastest, but may be prone to roundoff errors and/or overflow. <br /></td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65" id="r_a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top"><a id="a9b64954fb374b16e1fe991e435501d65" name="a9b64954fb374b16e1fe991e435501d65"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> { <b>UNKNOWN</b>
, <b>PRIME</b>
, <b>PROB_PRIME</b>
, <b>COMPOSITE</b>
 }</td></tr>
<tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or don’t care). <br /></td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0" id="r_a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> { <br />
&#160;&#160;<b>LENGTH</b>
, <b>SPECTRAL</b>
, <b>BEYER</b>
, <b>PALPHA</b>
, <br />
&#160;&#160;<b>BOUND_JS</b>
<br />
 }</td></tr>
<tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the merit criterion for ranking generators or lattices.  <a href="#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90" id="r_ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> { <br />
&#160;&#160;<b>BESTLAT</b>
, <b>BESTBOUND</b>
, <b>LAMINATED</b>
, <b>ROGERS</b>
, <br />
&#160;&#160;<b>MINK</b>
, <b>MINKL1</b>
, <b>L1</b>
, <b>L2</b>
, <br />
&#160;&#160;<b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\).  <a href="#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe" id="r_a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> { <b>PAL</b>
, <b>NORMPAL</b>
, <b>BAL</b>
, <b>SEEKPAL</b>
 }</td></tr>
<tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191af830e61af769e233e1b03138520e" id="r_a191af830e61af769e233e1b03138520e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a191af830e61af769e233e1b03138520e">PreReductionType</a> { <br />
&#160;&#160;<b>NOPRERED</b>
, <b>DIETER</b>
, <b>LLL</b>
, <b>BKZ</b>
, <br />
&#160;&#160;<b>FULL</b>
<br />
 }</td></tr>
<tr class="memdesc:a191af830e61af769e233e1b03138520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all the possible lattice reduction implemented in <code><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code>.  <a href="#a191af830e61af769e233e1b03138520e">More...</a><br /></td></tr>
<tr class="separator:a191af830e61af769e233e1b03138520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61a624270d67110531f2dea4c739eff5" id="r_a61a624270d67110531f2dea4c739eff5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a624270d67110531f2dea4c739eff5">lFactorial</a> (int t)</td></tr>
<tr class="memdesc:a61a624270d67110531f2dea4c739eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <br /></td></tr>
<tr class="separator:a61a624270d67110531f2dea4c739eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e" id="r_a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top"><a id="a886c94b54767104cea58e0f1b6c0d11e" name="a886c94b54767104cea58e0f1b6c0d11e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Digamma</b> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). <br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e699673c28800e0563b14a05392d1c0" id="r_a7e699673c28800e0563b14a05392d1c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e699673c28800e0563b14a05392d1c0">BernoulliPoly</a> (int n, double x)</td></tr>
<tr class="memdesc:a7e699673c28800e0563b14a05392d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <br /></td></tr>
<tr class="separator:a7e699673c28800e0563b14a05392d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4" id="r_a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top"><a id="a61a4b5013c295f9f07b9b2d8f26ee5f4" name="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Harmonic</b> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\). <br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0" id="r_a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum.  <br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd" id="r_a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[14]</a>)  <br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504" id="r_ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series.  <br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc70e568502a8240712a39087ac1aca" id="r_addc70e568502a8240712a39087ac1aca"><td class="memItemLeft" align="right" valign="top"><a id="addc70e568502a8240712a39087ac1aca" name="addc70e568502a8240712a39087ac1aca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>negativeCholeski</b> ()</td></tr>
<tr class="separator:addc70e568502a8240712a39087ac1aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932" id="r_ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes references to two variables of a generic type and swaps their content.  <br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade83b8750d65c6a2439a403120936cd0" id="r_ade83b8750d65c6a2439a403120936cd0"><td class="memItemLeft" align="right" valign="top"><a id="ade83b8750d65c6a2439a403120936cd0" name="ade83b8750d65c6a2439a403120936cd0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:ade83b8750d65c6a2439a403120936cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the coordinate set <code>coords</code> and outputs it to <code>os</code>. <br /></td></tr>
<tr class="separator:ade83b8750d65c6a2439a403120936cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c81ea931a77792ad768af0e8db97f" id="r_aa37c81ea931a77792ad768af0e8db97f"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#aa37c81ea931a77792ad768af0e8db97f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:aa37c81ea931a77792ad768af0e8db97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a formatted coordinate set from <code>is</code>.  <br /></td></tr>
<tr class="separator:aa37c81ea931a77792ad768af0e8db97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699825e25a2aad8d3e14b0f252f2e011" id="r_a699825e25a2aad8d3e14b0f252f2e011"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html#a699825e25a2aad8d3e14b0f252f2e011">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html">ProjectionDependentWeights</a> &amp;weights)</td></tr>
<tr class="memdesc:a699825e25a2aad8d3e14b0f252f2e011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted projection-dependent weights into the object <code>weights</code>.  <br /></td></tr>
<tr class="separator:a699825e25a2aad8d3e14b0f252f2e011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c12eea0f3df2908bb03fb2675add3" id="r_aef6c12eea0f3df2908bb03fb2675add3"><td class="memItemLeft" align="right" valign="top"><a id="aef6c12eea0f3df2908bb03fb2675add3" name="aef6c12eea0f3df2908bb03fb2675add3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a> &amp;o)</td></tr>
<tr class="memdesc:aef6c12eea0f3df2908bb03fb2675add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the type of weights, formats them and outputs them on <code>os</code>. <br /></td></tr>
<tr class="separator:aef6c12eea0f3df2908bb03fb2675add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">toString functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Useful functions for printing the <code>enum</code> constants in this module.</p>
<p>Returns the <code>enum</code> constants in this module as strings. </p>
</div></td></tr>
<tr class="memitem:ac17f66f1341665d9c723370f48489693" id="r_ac17f66f1341665d9c723370f48489693"><td class="memItemLeft" align="right" valign="top"><a id="ac17f66f1341665d9c723370f48489693" name="ac17f66f1341665d9c723370f48489693"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorm</b> (<a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>)</td></tr>
<tr class="separator:ac17f66f1341665d9c723370f48489693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193c5786aa6aba2c1336059420d59181" id="r_a193c5786aa6aba2c1336059420d59181"><td class="memItemLeft" align="right" valign="top"><a id="a193c5786aa6aba2c1336059420d59181" name="a193c5786aa6aba2c1336059420d59181"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrime</b> (<a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a>)</td></tr>
<tr class="separator:a193c5786aa6aba2c1336059420d59181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9355fb081813a1aeaa8e490747bbedc3" id="r_a9355fb081813a1aeaa8e490747bbedc3"><td class="memItemLeft" align="right" valign="top"><a id="a9355fb081813a1aeaa8e490747bbedc3" name="a9355fb081813a1aeaa8e490747bbedc3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCriterion</b> (<a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a>)</td></tr>
<tr class="separator:a9355fb081813a1aeaa8e490747bbedc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf28b36267abe9360e971340d8d41fc" id="r_a1cf28b36267abe9360e971340d8d41fc"><td class="memItemLeft" align="right" valign="top"><a id="a1cf28b36267abe9360e971340d8d41fc" name="a1cf28b36267abe9360e971340d8d41fc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringProblem</b> (<a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a>)</td></tr>
<tr class="separator:a1cf28b36267abe9360e971340d8d41fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e4bcc4985daad5d4c3c358700558f" id="r_a9d1e4bcc4985daad5d4c3c358700558f"><td class="memItemLeft" align="right" valign="top"><a id="a9d1e4bcc4985daad5d4c3c358700558f" name="a9d1e4bcc4985daad5d4c3c358700558f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringNorma</b> (<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a>)</td></tr>
<tr class="separator:a9d1e4bcc4985daad5d4c3c358700558f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643e27a6bdf128918650e17152750393" id="r_a643e27a6bdf128918650e17152750393"><td class="memItemLeft" align="right" valign="top"><a id="a643e27a6bdf128918650e17152750393" name="a643e27a6bdf128918650e17152750393"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringCalc</b> (<a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a>)</td></tr>
<tr class="separator:a643e27a6bdf128918650e17152750393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac079459fae7767d1d4c44c55ed38088d" id="r_ac079459fae7767d1d4c44c55ed38088d"><td class="memItemLeft" align="right" valign="top"><a id="ac079459fae7767d1d4c44c55ed38088d" name="ac079459fae7767d1d4c44c55ed38088d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPreRed</b> (<a class="el" href="#a191af830e61af769e233e1b03138520e">PreReductionType</a>)</td></tr>
<tr class="separator:ac079459fae7767d1d4c44c55ed38088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487d2f08dbaa9b4ddc5c6d970b09647a" id="r_a487d2f08dbaa9b4ddc5c6d970b09647a"><td class="memItemLeft" align="right" valign="top"><a id="a487d2f08dbaa9b4ddc5c6d970b09647a" name="a487d2f08dbaa9b4ddc5c6d970b09647a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringOutput</b> (<a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a>)</td></tr>
<tr class="separator:a487d2f08dbaa9b4ddc5c6d970b09647a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19db275d7c64eac012aaca3f2b7e6043" id="r_a19db275d7c64eac012aaca3f2b7e6043"><td class="memItemLeft" align="right" valign="top"><a id="a19db275d7c64eac012aaca3f2b7e6043" name="a19db275d7c64eac012aaca3f2b7e6043"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringPrecision</b> (<a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>)</td></tr>
<tr class="separator:a19db275d7c64eac012aaca3f2b7e6043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All the functions of this module use LFSR258 as an underlying source for pseudo-random numbers.</p>
<p>A free (as in freedom) implementation of this generator can be found at <a href="http://simul.iro.umontreal.ca/">http://simul.iro.umontreal.ca/</a> as well as the article presenting it. All the functions generating some sort of random number will advance an integer version of LFSR258 by one state and output a transformation of the state to give a double, an int or bits. </p>
</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4" id="r_abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e829d77e42c8dbabc8f6e37eca2a714" id="r_a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e829d77e42c8dbabc8f6e37eca2a714">RandInt</a> (int i, int j)</td></tr>
<tr class="memdesc:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform pseudo-random integer in \([i, j]\).  <br /></td></tr>
<tr class="separator:a8e829d77e42c8dbabc8f6e37eca2a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8827c239bd1293eacd356e5cbe3b2" id="r_a56b8827c239bd1293eacd356e5cbe3b2"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56b8827c239bd1293eacd356e5cbe3b2">RandBits</a> (int s)</td></tr>
<tr class="memdesc:a56b8827c239bd1293eacd356e5cbe3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer.  <br /></td></tr>
<tr class="separator:a56b8827c239bd1293eacd356e5cbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658" id="r_a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are complete reimplementation of certain mathematical functions, or wrappers for standard C/C++ functions. </p>
</div></td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf" id="r_a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top"><a id="a9abb8da9fdc5fa2c37d44165f8660aaf" name="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mysqrt</b> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). <br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b" id="r_ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2"><a id="ae12db9335c229d7c60e570dab50ef05b" name="ae12db9335c229d7c60e570dab50ef05b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Lg</b> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef" id="r_a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top"><a id="a12e4b6c931cf0a19642828796b3b3bef" name="a12e4b6c931cf0a19642828796b3b3bef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Lg</b> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2. <br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed" id="r_a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2"><a id="a67e0668a966fb5fa3e22fc1ffa6d59ed" name="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of \(x\). <br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c" id="r_a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of <code>x</code>.  <br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d" id="r_a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of x rounded to the NEAREST integer value.  <br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9b920d83981962589ceb0d16d6d08" id="r_a10b9b920d83981962589ceb0d16d6d08"><td class="memItemLeft" align="right" valign="top"><a id="a10b9b920d83981962589ceb0d16d6d08" name="a10b9b920d83981962589ceb0d16d6d08"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>Factorial</b> (int t)</td></tr>
<tr class="memdesc:a10b9b920d83981962589ceb0d16d6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t. <br /></td></tr>
<tr class="separator:a10b9b920d83981962589ceb0d16d6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and modular arithmetic</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a>.</dd></dl>
<p>This module offers function to perform division and find remainders in a standard way. These functions are usefull in the case where one wants to do divisions or find remainders of operations with negative operands. The reason is that <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> and primitive types do not use the same logic when doing calculations on negative numbers.</p>
<p>Basically, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> will always floor a division and C++ will always truncate a division (which effectively means the floor function is replaced by a roof function if the answer is a negative number). When calculating the remainder of x/y, both apply the same logic but get a different result because they do not do the same division. In both representations, we have that   </p><p class="formulaDsp">
\[
   y\cdot(x/y) + x%y = x.
\]
</p>
<p> It turns out that, with negative values, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> will return an integer with the same sign as y where C++ will return an integer of opposite sign (but both will return the same number modulo y). </p>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f" id="r_aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>a/b</code>, truncates the fractionnal part and puts the result in q.  <br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327" id="r_a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="memdesc:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of a/b and stores its positive equivalent mod b in r.  <br /></td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570" id="r_aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\).  <br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772" id="r_a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5" id="r_a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top"><a id="a14db19d396c104b730dd5ea23a7752b5" name="a14db19d396c104b730dd5ea23a7752b5"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>gcd</b> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm. <br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d" id="r_abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm.  <br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are utilities to manipulate vectors ranging from instanciation to scalar product. </p>
</div></td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836" id="r_a2256248f03b45f7125a46a05c49b8836"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2256248f03b45f7125a46a05c49b8836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2256248f03b45f7125a46a05c49b8836">CreateVect</a> (Real *&amp;A, int d)</td></tr>
<tr class="memdesc:a2256248f03b45f7125a46a05c49b8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a2256248f03b45f7125a46a05c49b8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f" id="r_a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a1b8b3b162c15420c29f622c74452ab5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b8b3b162c15420c29f622c74452ab5f">CreateVect</a> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a1b8b3b162c15420c29f622c74452ab5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a1b8b3b162c15420c29f622c74452ab5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3" id="r_a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898" id="r_a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>, destroying all the elements it contains.  <br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5" id="r_a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplParams" colspan="2"><a id="a80ff1882a1a3efdc5265695e4827bda5" name="a80ff1882a1a3efdc5265695e4827bda5"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a80ff1882a1a3efdc5265695e4827bda5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetZero</b> (Real *A, int d)</td></tr>
<tr class="memdesc:a80ff1882a1a3efdc5265695e4827bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> of <code>A</code> to 0. <br /></td></tr>
<tr class="separator:a80ff1882a1a3efdc5265695e4827bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18" id="r_a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplParams" colspan="2"><a id="a3ae135eb75ddb3c6cb8f452afc34cf18" name="a3ae135eb75ddb3c6cb8f452afc34cf18"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetZero</b> (Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0. <br /></td></tr>
<tr class="separator:a3ae135eb75ddb3c6cb8f452afc34cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e" id="r_a07e941416f7b2402d15045a459e4196e"><td class="memTemplParams" colspan="2"><a id="a07e941416f7b2402d15045a459e4196e" name="a07e941416f7b2402d15045a459e4196e"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a07e941416f7b2402d15045a459e4196e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetValue</b> (Real *A, int d, const Real &amp;x)</td></tr>
<tr class="memdesc:a07e941416f7b2402d15045a459e4196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to the value <code>x</code>. <br /></td></tr>
<tr class="separator:a07e941416f7b2402d15045a459e4196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8c9d98d5ebd8cb7d73cec8a8e93c13" id="r_a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">toString</a> (const Vect &amp;A, int c, int d, const char *sep=&quot; &quot;)</td></tr>
<tr class="memdesc:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>.  <br /></td></tr>
<tr class="separator:a8c8c9d98d5ebd8cb7d73cec8a8e93c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d" id="r_a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a0a994e5f949c8b1315d0324e7826240d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a994e5f949c8b1315d0324e7826240d">toString</a> (const Vect &amp;A, int d)</td></tr>
<tr class="memdesc:a0a994e5f949c8b1315d0324e7826240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string.  <br /></td></tr>
<tr class="separator:a0a994e5f949c8b1315d0324e7826240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc" id="r_a53d8462179e4ca773d33843c15c77afc"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:a53d8462179e4ca773d33843c15c77afc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53d8462179e4ca773d33843c15c77afc">ProdScal</a> (const Vect1 &amp;A, const Vect2 &amp;B, int n, Scal &amp;D)</td></tr>
<tr class="memdesc:a53d8462179e4ca773d33843c15c77afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>.  <br /></td></tr>
<tr class="separator:a53d8462179e4ca773d33843c15c77afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a" id="r_a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplParams" colspan="2">template&lt;typename IntVec &gt; </td></tr>
<tr class="memitem:a8380e2ebec791f472a3634348bc0e22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8380e2ebec791f472a3634348bc0e22a">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int n)</td></tr>
<tr class="memdesc:a8380e2ebec791f472a3634348bc0e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>.  <br /></td></tr>
<tr class="separator:a8380e2ebec791f472a3634348bc0e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6" id="r_a7022d363aa696d09b59c9499745466a6"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a7022d363aa696d09b59c9499745466a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7022d363aa696d09b59c9499745466a6">CalcNorm</a> (const Vect &amp;V, int n, Scal &amp;S, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a7022d363aa696d09b59c9499745466a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>.  <br /></td></tr>
<tr class="separator:a7022d363aa696d09b59c9499745466a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472" id="r_ada47b56ab96c49d7508b9379d0134472"><td class="memTemplParams" colspan="2"><a id="ada47b56ab96c49d7508b9379d0134472" name="ada47b56ab96c49d7508b9379d0134472"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ada47b56ab96c49d7508b9379d0134472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CopyVect</b> (Vect &amp;A, const Vect &amp;B, int n)</td></tr>
<tr class="memdesc:ada47b56ab96c49d7508b9379d0134472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>. <br /></td></tr>
<tr class="separator:ada47b56ab96c49d7508b9379d0134472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f" id="r_ad43d2de9716e712790093eff2c12631f"><td class="memTemplParams" colspan="2">template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:ad43d2de9716e712790093eff2c12631f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad43d2de9716e712790093eff2c12631f">ModifVect</a> (Vect1 &amp;A, const Vect2 &amp;B, Scal x, int n)</td></tr>
<tr class="memdesc:ad43d2de9716e712790093eff2c12631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>.  <br /></td></tr>
<tr class="separator:ad43d2de9716e712790093eff2c12631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4" id="r_a127802e517a91268330bad9930e5a5f4"><td class="memTemplParams" colspan="2"><a id="a127802e517a91268330bad9930e5a5f4" name="a127802e517a91268330bad9930e5a5f4"></a>
template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a127802e517a91268330bad9930e5a5f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ChangeSign</b> (Vect &amp;A, int n)</td></tr>
<tr class="memdesc:a127802e517a91268330bad9930e5a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>. <br /></td></tr>
<tr class="separator:a127802e517a91268330bad9930e5a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2df72413bf638fb96e4a4d0e078828" id="r_adf2df72413bf638fb96e4a4d0e078828"><td class="memItemLeft" align="right" valign="top"><a id="adf2df72413bf638fb96e4a4d0e078828" name="adf2df72413bf638fb96e4a4d0e078828"></a>
std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GCD2vect</b> (std::vector&lt; std::int64_t &gt; V, int k, int n)</td></tr>
<tr class="memdesc:adf2df72413bf638fb96e4a4d0e078828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>. <br /></td></tr>
<tr class="separator:adf2df72413bf638fb96e4a4d0e078828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad" id="r_ac21669d8af13d92327accdc26e9444ad"><td class="memTemplParams" colspan="2"><a id="ac21669d8af13d92327accdc26e9444ad" name="ac21669d8af13d92327accdc26e9444ad"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:ac21669d8af13d92327accdc26e9444ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:ac21669d8af13d92327accdc26e9444ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:ac21669d8af13d92327accdc26e9444ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e" id="r_adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplParams" colspan="2"><a id="adfafd877b46442cc4b215448f25ccd7e" name="adfafd877b46442cc4b215448f25ccd7e"></a>
template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adfafd877b46442cc4b215448f25ccd7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:adfafd877b46442cc4b215448f25ccd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix <code>A</code> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0. <br /></td></tr>
<tr class="separator:adfafd877b46442cc4b215448f25ccd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1" id="r_a5af883014a948b37a49d69f729db70f1"><td class="memTemplParams" colspan="2"><a id="a5af883014a948b37a49d69f729db70f1" name="a5af883014a948b37a49d69f729db70f1"></a>
template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a5af883014a948b37a49d69f729db70f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (IntMat &amp;A, int d)</td></tr>
<tr class="memdesc:a5af883014a948b37a49d69f729db70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d*d</code> and re-initializes its elements to 0. <br /></td></tr>
<tr class="separator:a5af883014a948b37a49d69f729db70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d" id="r_a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplParams" colspan="2"><a id="a75474ce5f96fabf95eff6824df3d6f3d" name="a75474ce5f96fabf95eff6824df3d6f3d"></a>
template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateMatr</b> (IntMat &amp;A, int line, int col)</td></tr>
<tr class="memdesc:a75474ce5f96fabf95eff6824df3d6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0. <br /></td></tr>
<tr class="separator:a75474ce5f96fabf95eff6824df3d6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c" id="r_a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a229c9368d745b9c4cae68c1b65e0e39c">DeleteMatr</a> (Real **&amp;A, int d)</td></tr>
<tr class="memdesc:a229c9368d745b9c4cae68c1b65e0e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d \times d\) matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a229c9368d745b9c4cae68c1b65e0e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35" id="r_a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c884b60a0c4ee06455bf1c8e1819d35">DeleteMatr</a> (Real **&amp;A, int line, int col)</td></tr>
<tr class="memdesc:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\).  <br /></td></tr>
<tr class="separator:a0c884b60a0c4ee06455bf1c8e1819d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524" id="r_a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <code>clear()</code> method on <code>A</code>.  <br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f" id="r_aac81709c183b536ab80b83384314457f"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aac81709c183b536ab80b83384314457f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac81709c183b536ab80b83384314457f">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int n)</td></tr>
<tr class="memdesc:aac81709c183b536ab80b83384314457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:aac81709c183b536ab80b83384314457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9" id="r_a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a8f32e22915b91e8c763f35b62c1039d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f32e22915b91e8c763f35b62c1039d9">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int line, int col)</td></tr>
<tr class="memdesc:a8f32e22915b91e8c763f35b62c1039d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a8f32e22915b91e8c763f35b62c1039d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e" id="r_ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">toStr</a> (const MatT &amp;mat, int d1, int d2)</td></tr>
<tr class="memdesc:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is a representation of <code>mat</code>.  <br /></td></tr>
<tr class="separator:ab1f9c94abf76e8ce25eb60bb6d1bda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05684550e5a7aa0b7d625024702a966d" id="r_a05684550e5a7aa0b7d625024702a966d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a05684550e5a7aa0b7d625024702a966d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05684550e5a7aa0b7d625024702a966d">CheckTriangular</a> (const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;A, long dim, const Int m)</td></tr>
<tr class="memdesc:a05684550e5a7aa0b7d625024702a966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>.  <br /></td></tr>
<tr class="separator:a05684550e5a7aa0b7d625024702a966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093" id="r_aa519a1e0589932719c79b73c76bb1093"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:aa519a1e0589932719c79b73c76bb1093"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa519a1e0589932719c79b73c76bb1093">Triangularization</a> (Matr &amp;W, Matr &amp;V, int lin, int col, const Int &amp;m)</td></tr>
<tr class="memdesc:aa519a1e0589932719c79b73c76bb1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>W</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>V</code>.  <br /></td></tr>
<tr class="separator:aa519a1e0589932719c79b73c76bb1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0" id="r_a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17df0e6fdb1f11335eaf91f82ee298b0">CalcDual</a> (const Matr &amp;A, Matr &amp;B, int d, const Int &amp;m)</td></tr>
<tr class="memdesc:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an upper triangular basis <code>A</code> and computes a dual lattice basis modulo <code>m</code> to this matrix.  <br /></td></tr>
<tr class="separator:a17df0e6fdb1f11335eaf91f82ee298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a49105dd8e915243488440f570b3951bd" id="r_a49105dd8e915243488440f570b3951bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49105dd8e915243488440f570b3951bd">MyExit</a> (int status, std::string msg)</td></tr>
<tr class="memdesc:a49105dd8e915243488440f570b3951bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <br /></td></tr>
<tr class="separator:a49105dd8e915243488440f570b3951bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Printing functions and operators</div></td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1" id="r_a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplParams" colspan="2">template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c5c3904af8b547eb32bba8d42b5c3b1">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for maps.  <br /></td></tr>
<tr class="separator:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d" id="r_a00572b373d97cc0227547867bd1cde0d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00572b373d97cc0227547867bd1cde0d">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a00572b373d97cc0227547867bd1cde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a00572b373d97cc0227547867bd1cde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650" id="r_a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ddcbc9a5e063f35176f9c48d38f2650">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664" id="r_a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplParams" colspan="2">template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97b28ac9e1e15b5ede018202a73fe664">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a97b28ac9e1e15b5ede018202a73fe664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for sets.  <br /></td></tr>
<tr class="separator:a97b28ac9e1e15b5ede018202a73fe664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac1cde17f5342cb2c65abae29049ea354" id="r_ac1cde17f5342cb2c65abae29049ea354"><td class="memItemLeft" align="right" valign="top"><a id="ac1cde17f5342cb2c65abae29049ea354" name="ac1cde17f5342cb2c65abae29049ea354"></a>
const std::array&lt; unsigned int, NB_PRIMES &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PRIMES_ARRAY</b></td></tr>
<tr class="separator:ac1cde17f5342cb2c65abae29049ea354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8" id="r_ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top"><a id="ac9adbd421a1148216c8eac1b7d96a5b8" name="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LONG_DOUBLE</b> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). <br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f464bde0cd79b7bbc47ff090e49b31" id="r_ae5f464bde0cd79b7bbc47ff090e49b31"><td class="memItemLeft" align="right" valign="top"><a id="ae5f464bde0cd79b7bbc47ff090e49b31" name="ae5f464bde0cd79b7bbc47ff090e49b31"></a>
const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>TWO_EXP</b> []</td></tr>
<tr class="memdesc:ae5f464bde0cd79b7bbc47ff090e49b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). <br /></td></tr>
<tr class="separator:ae5f464bde0cd79b7bbc47ff090e49b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lattice namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe" name="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&#160;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a> <code>PAL</code> is for the \(P_{\alpha}\) test. <br  />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br  />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br  />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0" name="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&#160;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the merit criterion for ranking generators or lattices. </p>
<p><code>LENGTH</code>: Only using the length of the shortest vector as a criterion. <code>BEYER</code>: the figure of merit is the Beyer quotient \(Q_T\).<br  />
 <code>SPECTRAL</code>: the figure of merit \(S_T\) is based on the spectral test.<br  />
 <code>PALPHA</code>: the figure of merit is based on \(P_{\alpha}\).<br  />
 <code>BOUND_JS</code>: the figure of merit is based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rsin08a">[28]</a>.<br  />
 </p>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90" name="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&#160;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which normalization is used to compute \(S_t\) in the spectral test, for each dimension \(t\). </p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br  />
 <code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best bound known to us.<br  />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br  />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br  />
 <code>MINKOWSKI</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br  />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br  />
 <code>NONE</code>: no normalization will be used.<br  />
 </p>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4" name="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&#160;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which norm is used to measure the length of vectors. </p>
<p>For  \(X =
(x_1,…,x_t)\),</p>
<p><code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br  />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br  />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br  />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058" name="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&#160;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates in which form and where the results will be sent. </p>
<p><code>TERM</code>: the results will appear only on the terminal screen.<br  />
 <code>RES</code>: the results will be in plain text format and sent to a file with extension <code>.res</code>.<br  />
 <code>TEX</code>: the results will be in LaTeX format and sent to a file with extension <code>.tex</code>.<br  />
<code>GEN</code>: the results will be sent to a file with extension <code>.gen</code>. </p>

</div>
</div>
<a id="a191af830e61af769e233e1b03138520e" name="a191af830e61af769e233e1b03138520e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191af830e61af769e233e1b03138520e">&#9670;&#160;</a></span>PreReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a191af830e61af769e233e1b03138520e">LatticeTester::PreReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of all the possible lattice reduction implemented in <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code>. </p>
<p><code>NORPRERED</code>: no reduction <code>DIETER</code>: Pairwise reduction <code>LLL</code>: LLL reduction <code>BKZ</code>: block Korkine-Zolotarev reduction <code>FULL</code>: shortest vector search. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7e699673c28800e0563b14a05392d1c0" name="a7e699673c28800e0563b14a05392d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e699673c28800e0563b14a05392d1c0">&#9670;&#160;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are:           </p><p class="formulaDsp">
\begin{align*}
B_0(x) &amp;= 1  \\
B_1(x) &amp;= x - 1/2  \\
B_2(x) &amp;= x^2-x+1/6  \\
B_3(x) &amp;= x^3 - 3x^2/2 + x/2  \\
B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\
B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6  \\
B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42  \\
B_7(x) &amp;= x^7 - 7x^6/2 +  7x^5/2 - 7x^3/6 + x/6  \\
B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30.
\end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a17df0e6fdb1f11335eaf91f82ee298b0" name="a17df0e6fdb1f11335eaf91f82ee298b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df0e6fdb1f11335eaf91f82ee298b0">&#9670;&#160;</a></span>CalcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an upper triangular basis <code>A</code> and computes a dual lattice basis modulo <code>m</code> to this matrix. </p>
<p>For this algorithm to work, <code>A</code> as to be upper triangular and all the coefficients on the diagonal have to divide <code>m</code>.</p>
<p>For <code>B</code> to be a <code>m</code>-dual to <code>A</code>, we have to have that \(AB^t = mI\). It is quite easy to show that, knowing <code>A</code> is upper triangular, <code>B</code> will be a lower triangular matrix with <code>A(i,i)*B(i,i) = m</code> for all <code>i</code> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, and <a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#aef92565c07e9095cb426b573b04d5acc">LatticeTester::Rank1Lattice&lt; Int, BasInt, Dbl, RedDbl &gt;::buildBasis()</a>.</p>

</div>
</div>
<a id="a7022d363aa696d09b59c9499745466a6" name="a7022d363aa696d09b59c9499745466a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022d363aa696d09b59c9499745466a6">&#9670;&#160;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>. </p>
<p><code>Scal</code> has to be a floating point type. </p>

<p class="reference">References <a class="el" href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs()</a>, and <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a9b19ed2fc7846e8c619f866eb0d58c48">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateDualVecNorm()</a>, and <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a90c37c020f604e44edc392125f724a73">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateVecNorm()</a>.</p>

</div>
</div>
<a id="a05684550e5a7aa0b7d625024702a966d" name="a05684550e5a7aa0b7d625024702a966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05684550e5a7aa0b7d625024702a966d">&#9670;&#160;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>. </p>
<p>This will return <code>true</code> if all the elements under the diagonal are equal to zero modulo <code>m</code> and <code>false</code> otherwise. If <code>m</code> is <code>0</code>, this function simply verifies that the matrix is triangular. </p>

<p class="reference">Referenced by <a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#a0783fc67f85f004cd66c1035ef065b8a">LatticeTester::BasisConstruction&lt; BasInt &gt;::DualConstruction()</a>, and <a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#ab486a7a6110df22a049122bb81fb2bf9">LatticeTester::BasisConstruction&lt; BasInt &gt;::DualSlow()</a>.</p>

</div>
</div>
<a id="a8f32e22915b91e8c763f35b62c1039d9" name="a8f32e22915b91e8c763f35b62c1039d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f32e22915b91e8c763f35b62c1039d9">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(line \times col\). </p>

</div>
</div>
<a id="aac81709c183b536ab80b83384314457f" name="aac81709c183b536ab80b83384314457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81709c183b536ab80b83384314457f">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(n \times n\). </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a973c60c8ddd75c14cea87d084bb3e49c">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::copyBasis()</a>.</p>

</div>
</div>
<a id="a2256248f03b45f7125a46a05c49b8836" name="a2256248f03b45f7125a46a05c49b8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256248f03b45f7125a46a05c49b8836">&#9670;&#160;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0. </p>
<p><code>Real</code> has to be a numeric type. </p>

<p class="reference">Referenced by <a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#abfa0005744bccda2a6356c1bb8b591d4">LatticeTester::Lacunary&lt; BasInt &gt;::calcIndicesStreams()</a>, <a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#a8c91ccc16be251a222faa28853849c8f">LatticeTester::Lacunary&lt; BasInt &gt;::Lacunary()</a>, and <a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#a7dcc3dafb83ab3b880d79b5862f1a6a9">LatticeTester::Lacunary&lt; BasInt &gt;::Lacunary()</a>.</p>

</div>
</div>
<a id="a1b8b3b162c15420c29f622c74452ab5f" name="a1b8b3b162c15420c29f622c74452ab5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8b3b162c15420c29f622c74452ab5f">&#9670;&#160;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0. </p>
<p>The type <code>Vect</code> has to have a <code>resize(integer_type)</code> method that sets the size of the instance to the value of the argument. </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524" name="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the <code>clear()</code> method on <code>A</code>. </p>
<p><code>A</code> has to have a <code>clear()</code> method that frees the memory allocated to it. </p>

</div>
</div>
<a id="a229c9368d745b9c4cae68c1b65e0e39c" name="a229c9368d745b9c4cae68c1b65e0e39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229c9368d745b9c4cae68c1b65e0e39c">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d \times d\) matrix <code>A</code>. </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a0c884b60a0c4ee06455bf1c8e1819d35" name="a0c884b60a0c4ee06455bf1c8e1819d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c884b60a0c4ee06455bf1c8e1819d35">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\). </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3" name="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>. </p>
<p>This calls <code>delete[]</code> on <code>A</code> so trying to access <code>A</code> after using this is unsafe. </p>

<p class="reference">Referenced by <a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#abfa0005744bccda2a6356c1bb8b591d4">LatticeTester::Lacunary&lt; BasInt &gt;::calcIndicesStreams()</a>, and <a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#a3297da5b3fb2dfd27843307b10e54c89">LatticeTester::Lacunary&lt; BasInt &gt;::~Lacunary()</a>.</p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898" name="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>, destroying all the elements it contains. </p>
<p><code>Vect</code> type has to have a <code>clear()</code> method that deallocates all the elements in the vector. </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570" name="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&#160;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). This works with std::int64_t, NTL::ZZ and real numbers.</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772" name="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&#160;</a></span>DivideRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

<p class="reference">Referenced by <a class="el" href="#a17df0e6fdb1f11335eaf91f82ee298b0">CalcDual()</a>, and <a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#a0783fc67f85f004cd66c1035ef065b8a">LatticeTester::BasisConstruction&lt; BasInt &gt;::DualConstruction()</a>.</p>

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d" name="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&#160;</a></span>Euclide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm. </p>
<p>This will store this gcd in <code>G</code> and also the linear combination that permits to get <code>G</code> from <code>A</code> and <code>B</code>. This function should work with std::int64_t and NTL::ZZ.</p>
<p>For \(A\) and \(B\) this will assign to \(C\), \(D\), \(E\), \(F\) and \(G\) values such that:    </p><p class="formulaDsp">
\begin{align*}
   C a + D b &amp; = G = \mbox{GCD } (a,b)\\
  E a + F b &amp; = 0.
\end{align*}
</p>
 
<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, <a class="el" href="../../d2/d5a/namespaceNTL.html#a1629b29c99a1aed8f591c523c9047519">NTL::IsZero()</a>, <a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient()</a>, <a class="el" href="../../d2/d5a/namespaceNTL.html#a968f8ba311c0012dd1ee4f024ae54e51">NTL::set()</a>, and <a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#aa519a1e0589932719c79b73c76bb1093">Triangularization()</a>.</p>

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd" name="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&#160;</a></span>FourierC1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[14]</a>) </p>
<p class="formulaDsp">
\[
S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}.
\]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504" name="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&#160;</a></span>FourierE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series. </p>
<p class="formulaDsp">
\[
G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\;  \frac{e^{2\pi i h x}}{|h|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0" name="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&#160;</a></span>Harmonic2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum. </p>
<p class="formulaDsp">
\[
\sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="a8380e2ebec791f472a3634348bc0e22a" name="a8380e2ebec791f472a3634348bc0e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8380e2ebec791f472a3634348bc0e22a">&#9670;&#160;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>. </p>
<p><code>B</code> is assumed to be of dimension at least <code>n+1</code>. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a61a624270d67110531f2dea4c739eff5" name="a61a624270d67110531f2dea4c739eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a624270d67110531f2dea4c739eff5">&#9670;&#160;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>
<p>Might throw if <code>t</code> is too large or if std::int64_t can't contain the factorial asked for. </p>

</div>
</div>
<a id="ad43d2de9716e712790093eff2c12631f" name="ad43d2de9716e712790093eff2c12631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43d2de9716e712790093eff2c12631f">&#9670;&#160;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>. </p>
<p>This will modify <code>A</code>. This does wierd type convertion and might not work well if different types are used. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327" name="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&#160;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of a/b and stores its positive equivalent mod b in r. </p>
<p>This works with std::int64_t, NTL::ZZ and real valued numbers. </p>

<p class="reference">Referenced by <a class="el" href="#aa519a1e0589932719c79b73c76bb1093">Triangularization()</a>.</p>

</div>
</div>
<a id="a49105dd8e915243488440f570b3951bd" name="a49105dd8e915243488440f570b3951bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49105dd8e915243488440f570b3951bd">&#9670;&#160;</a></span>MyExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::MyExit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the status code to return to the system, <code>msg</code> is the message to print upon exit. </p>

<p class="reference">Referenced by <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#a68235b33d81fc119b2006b3dbbcb426d">LatticeTester::IntLattice&lt; Int, BasInt, Dbl, RedDbl &gt;::buildBasis()</a>, <a class="el" href="../../d0/d18/classLatticeTester_1_1BasisConstruction.html#a32a4a2a2e8e85c616c45fdecbb4d6b72">LatticeTester::BasisConstruction&lt; BasInt &gt;::ProjectionConstruction()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a22854b92043cb754f126c8e71ace860d">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readBool()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a3cb1010d2c813be3b7ad43d9ff91fb46">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readCriterionType()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#ab3f19939355c336f1fb366c8d1e45fb8">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readNormaType()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a66773203622b226982ae41abb70f059f">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readNormType()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a0148a6b8d4e74ed4868f0546de5d38ff">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readOutputType()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a9768493deaa93c9e4e6f86583cbf1e50">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readPrecisionType()</a>, <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#ad351fb4607d09192c836cc6e180a1e36">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readPreRed()</a>, and <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a779ba2b06051c9cee4208e8bccc7e526">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readProblemType()</a>.</p>

</div>
</div>
<a id="a9c5c3904af8b547eb32bba8d42b5c3b1" name="a9c5c3904af8b547eb32bba8d42b5c3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c3904af8b547eb32bba8d42b5c3b1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for maps. </p>
<p>Formats a map as: <code>{ key1=&gt;val1, ..., keyN=&gt;valN }</code>. </p>

</div>
</div>
<a id="a00572b373d97cc0227547867bd1cde0d" name="a00572b373d97cc0227547867bd1cde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00572b373d97cc0227547867bd1cde0d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code>(first,second)</code>. </p>

</div>
</div>
<a id="a97b28ac9e1e15b5ede018202a73fe664" name="a97b28ac9e1e15b5ede018202a73fe664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b28ac9e1e15b5ede018202a73fe664">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for sets. </p>
<p>Formats a set as: <code>{ val1, ..., valN }</code>. </p>

</div>
</div>
<a id="a0ddcbc9a5e063f35176f9c48d38f2650" name="a0ddcbc9a5e063f35176f9c48d38f2650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcbc9a5e063f35176f9c48d38f2650">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="a53d8462179e4ca773d33843c15c77afc" name="a53d8462179e4ca773d33843c15c77afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8462179e4ca773d33843c15c77afc">&#9670;&#160;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const Vect1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>. </p>
<p>There is a lot to consider when passing types to this function. The best is for <code>Vect1</code> to be the same type as <code>Vect2</code> and for <code>Scal</code> to be the same as <code>Int</code>, and that those types are the ones stored in <code>Vect1</code> and <code>Vect2</code>.</p>
<p><b>WARNING</b>: This uses so many types without check about them and also assumes all those types can be converted to each other without problem. This is used in many places to compute a floating point norm of vectors with integers values. Take care when using this function. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a3aef5ff1c24b10130431c35f3a19b1e0">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::checkDuality()</a>, <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a8a721648af8cc007c1ce1c3ec5622bfc">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateDualScalL2Norm()</a>, <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a9b19ed2fc7846e8c619f866eb0d58c48">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateDualVecNorm()</a>, <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#acba5649464292d20c374208a0f06ae4c">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateScalL2Norm()</a>, and <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a90c37c020f604e44edc392125f724a73">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::updateVecNorm()</a>.</p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f" name="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&#160;</a></span>Quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>a/b</code>, truncates the fractionnal part and puts the result in q. </p>
<p>This function is overloaded to work as specified on NTL::ZZ integers. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
<p class="reference">Referenced by <a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide()</a>, and <a class="el" href="#aa519a1e0589932719c79b73c76bb1093">Triangularization()</a>.</p>

</div>
</div>
<a id="a56b8827c239bd1293eacd356e5cbe3b2" name="a56b8827c239bd1293eacd356e5cbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b8827c239bd1293eacd356e5cbe3b2">&#9670;&#160;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer. </p>
<p>It is imperative that \(1 \leq s \leq 64\) because the RNG is 64 bits wide. </p>

</div>
</div>
<a id="a8e829d77e42c8dbabc8f6e37eca2a714" name="a8e829d77e42c8dbabc8f6e37eca2a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e829d77e42c8dbabc8f6e37eca2a714">&#9670;&#160;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uniform pseudo-random integer in \([i, j]\). </p>
<p>Note that the numbers \(i\) and \(j\) are part of the possible output. It is important that \(i &lt; j\) because the underlying arithmetic uses unsigned integers to store j-i+1 and that will be undefined behavior. </p>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4" name="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&#160;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number will have 53 pseudo-random bits. </p>

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d" name="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&#160;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of x rounded to the NEAREST integer value. </p>
<p>(This does not truncate the integer value as is usual in computer arithmetic.) </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658" name="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&#160;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>Because of the constraints on the state, <code>seed</code> has to be \( &gt; 2\). If this is never called, a default seed will be used. </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c" name="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of <code>x</code>. </p>
<p>The sign is 1 if <code>x&gt;0</code>, 0 if <code>x==0</code> and -1 if <code>x&lt;0</code>. </p>

<p class="reference">Referenced by <a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html#a0691720136e032ccfca138d12fcf0c7d">LatticeTester::ParamReader&lt; Int, BasInt, RedDbl &gt;::readNumber3()</a>.</p>

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932" name="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&#160;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes references to two variables of a generic type and swaps their content. </p>
<p>This uses the assignment operator, so it might not always work well if this operator's implementation is not thorough. </p>

<p class="reference">Referenced by <a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide()</a>, <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a666ed5b323f58f8d4c9dcace46aeddec">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::permute()</a>, and <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html#a0e5ed9b05edc7c6ce235fa0f1631fc35">LatticeTester::IntLatticeBasis&lt; Int, BasInt, Dbl, RedDbl &gt;::permuteNoDual()</a>.</p>

</div>
</div>
<a id="ab1f9c94abf76e8ce25eb60bb6d1bda2e" name="ab1f9c94abf76e8ce25eb60bb6d1bda2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f9c94abf76e8ce25eb60bb6d1bda2e">&#9670;&#160;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that is a representation of <code>mat</code>. </p>
<p>This string will represent the \(d1 \times d2\) submatrix of the first lines and colums of <code>mat</code>. </p>

</div>
</div>
<a id="a8c8c9d98d5ebd8cb7d73cec8a8e93c13" name="a8c8c9d98d5ebd8cb7d73cec8a8e93c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">&#9670;&#160;</a></span>toString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>. </p>
<p>In this string, components are separated by string <code>sep</code>. By default, <code>sep</code> is just a whitespace character. </p>

<p class="reference">Referenced by <a class="el" href="#a0a994e5f949c8b1315d0324e7826240d">toString()</a>, and <a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#a0d17717d737fb62d56d0e63a287249ef">LatticeTester::Rank1Lattice&lt; Int, BasInt, Dbl, RedDbl &gt;::toStringCoef()</a>.</p>

</div>
</div>
<a id="a0a994e5f949c8b1315d0324e7826240d" name="a0a994e5f949c8b1315d0324e7826240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a994e5f949c8b1315d0324e7826240d">&#9670;&#160;</a></span>toString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string. </p>
<p>Calls <code>toString(const Vect&amp;, int, int, const char*)</code>. </p>

<p class="reference">References <a class="el" href="#a8c8c9d98d5ebd8cb7d73cec8a8e93c13">toString()</a>.</p>

</div>
</div>
<a id="aa519a1e0589932719c79b73c76bb1093" name="aa519a1e0589932719c79b73c76bb1093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519a1e0589932719c79b73c76bb1093">&#9670;&#160;</a></span>Triangularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>W</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>W</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>V</code>. </p>
<p><code>W</code> and <code>V</code> have to have more lines than <code>lin</code> and more columns than <code>col</code> since this algorithm will only operate on the upper <code>lin*col</code> matrix of <code>W</code>. All the computations will be done modulo <code>m</code>, which means that you must know a rescalling factor for the vector system to call this function. After the execution, <code>W</code> will be a matrix containing irrelevant information and <code>V</code> will contain an upper triangular basis.</p>
<p>For more details please look at <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[5]</a>. This algorithm basically implements what is written at the end of the article, that is the matrix <code>W</code> contains the set of vectors that is used and modified at each step to get a new vector from the basis. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677">NTL::clear()</a>, <a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide()</a>, <a class="el" href="../../d2/d5a/namespaceNTL.html#a1629b29c99a1aed8f591c523c9047519">NTL::IsZero()</a>, <a class="el" href="#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo()</a>, and <a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#aef92565c07e9095cb426b573b04d5acc">LatticeTester::Rank1Lattice&lt; Int, BasInt, Dbl, RedDbl &gt;::buildBasis()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated on Thu Aug 21 2025 21:35:06 for LatNet Builder Manual by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
