<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LatNet Builder Manual
   &#160;<span id="projectnumber">1.5.0-dev-287</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d8/de3/classLatticeTester_1_1Reducer.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../d4/d16/classLatticeTester_1_1Reducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and to find the shortest non-zero vector of the lattice using pre-reductions and a branch-and-bound (BB) algorithm <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[17]</a>&thinsp;.  
 <a href="../../d8/de3/classLatticeTester_1_1Reducer.html#details">More...</a></p>

<p><code>#include &lt;Reducer.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8211e2e27585eb711a42d69ed4ed255d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a8211e2e27585eb711a42d69ed4ed255d">Reducer</a> (<a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl &gt; &amp;lat)</td></tr>
<tr class="memdesc:a8211e2e27585eb711a42d69ed4ed255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a8211e2e27585eb711a42d69ed4ed255d">More...</a><br /></td></tr>
<tr class="separator:a8211e2e27585eb711a42d69ed4ed255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d48cc2e423c2a878a1f9c57465f725"><td class="memItemLeft" align="right" valign="top"><a id="a15d48cc2e423c2a878a1f9c57465f725"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a15d48cc2e423c2a878a1f9c57465f725">Reducer</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; &amp;red)</td></tr>
<tr class="memdesc:a15d48cc2e423c2a878a1f9c57465f725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a15d48cc2e423c2a878a1f9c57465f725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3886d6a10784dabb9e3edde5d632435"><td class="memItemLeft" align="right" valign="top"><a id="ad3886d6a10784dabb9e3edde5d632435"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ad3886d6a10784dabb9e3edde5d632435">~Reducer</a> ()</td></tr>
<tr class="memdesc:ad3886d6a10784dabb9e3edde5d632435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ad3886d6a10784dabb9e3edde5d632435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dd9a23196331fa0949b7c627d85a7c"><td class="memItemLeft" align="right" valign="top"><a id="ae0dd9a23196331fa0949b7c627d85a7c"></a>
<a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ae0dd9a23196331fa0949b7c627d85a7c">operator=</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; &amp;red)</td></tr>
<tr class="memdesc:ae0dd9a23196331fa0949b7c627d85a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:ae0dd9a23196331fa0949b7c627d85a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fe771397c464ffa4b406e517db9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a5f8fe771397c464ffa4b406e517db9b7">copy</a> (const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; &amp;red)</td></tr>
<tr class="memdesc:a5f8fe771397c464ffa4b406e517db9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the reducer <code>red</code> into this object.  <a href="#a5f8fe771397c464ffa4b406e517db9b7">More...</a><br /></td></tr>
<tr class="separator:a5f8fe771397c464ffa4b406e517db9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0edaf68051f1f63d8f892a4e7c0352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aee0edaf68051f1f63d8f892a4e7c0352">transformStage3</a> (std::vector&lt; std::int64_t &gt; &amp;z, int &amp;k)</td></tr>
<tr class="memdesc:aee0edaf68051f1f63d8f892a4e7c0352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method used in <code>reductMinkowski</code> to perform a transformation of stage 3 described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rAFF85a">[1]</a>&thinsp;.  <a href="#aee0edaf68051f1f63d8f892a4e7c0352">More...</a><br /></td></tr>
<tr class="separator:aee0edaf68051f1f63d8f892a4e7c0352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a04bb86d44bc7443ce327e3f6f16c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a23a04bb86d44bc7443ce327e3f6f16c4">calculCholeski</a> (RedDblVec &amp;DC2, RedDblMat &amp;C0)</td></tr>
<tr class="memdesc:a23a04bb86d44bc7443ce327e3f6f16c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a Choleski decomposition of the basis.  <a href="#a23a04bb86d44bc7443ce327e3f6f16c4">More...</a><br /></td></tr>
<tr class="separator:a23a04bb86d44bc7443ce327e3f6f16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02af7ccb0a0bee49bd76f33ba208b25"><td class="memItemLeft" align="right" valign="top"><a id="ab02af7ccb0a0bee49bd76f33ba208b25"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ab02af7ccb0a0bee49bd76f33ba208b25">tryZ</a> (int j, int i, int Stage, bool &amp;smaller, const BasIntMat &amp;WTemp)</td></tr>
<tr class="memdesc:ab02af7ccb0a0bee49bd76f33ba208b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find shorter vectors in <code>reductMinkowski</code>. <br /></td></tr>
<tr class="separator:ab02af7ccb0a0bee49bd76f33ba208b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b1f592b2cfc125a825d2735e717abf"><td class="memItemLeft" align="right" valign="top"><a id="a46b1f592b2cfc125a825d2735e717abf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a46b1f592b2cfc125a825d2735e717abf">tryZ0</a> (int j, bool &amp;smaller)</td></tr>
<tr class="memdesc:a46b1f592b2cfc125a825d2735e717abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a shorter vector in <code>shortestVector</code>. <br /></td></tr>
<tr class="separator:a46b1f592b2cfc125a825d2735e717abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8992d37e76b9c4ab29bab91f32f57f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a2f8992d37e76b9c4ab29bab91f32f57f">shortestVector</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a2f8992d37e76b9c4ab29bab91f32f57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shortest non-zero vector of this lattice with respect to norm <code>norm</code> using branch-and-bound and the algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[17]</a>&thinsp;.  <a href="#a2f8992d37e76b9c4ab29bab91f32f57f">More...</a><br /></td></tr>
<tr class="separator:a2f8992d37e76b9c4ab29bab91f32f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90d652ce4a94ecc2e39ba2ba494db49"><td class="memItemLeft" align="right" valign="top"><a id="ab90d652ce4a94ecc2e39ba2ba494db49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ab90d652ce4a94ecc2e39ba2ba494db49">shortestVectorDieter</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:ab90d652ce4a94ecc2e39ba2ba494db49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>ShortestVector</code> but uses the algorithm of Dieter <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_rKNU98a">[16]</a>&thinsp;. <br /></td></tr>
<tr class="separator:ab90d652ce4a94ecc2e39ba2ba494db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3888210b2464455cdc8ec5312941f1fb"><td class="memItemLeft" align="right" valign="top"><a id="a3888210b2464455cdc8ec5312941f1fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a3888210b2464455cdc8ec5312941f1fb">redBB</a> (int i, int d, int Stage, bool &amp;smaller)</td></tr>
<tr class="memdesc:a3888210b2464455cdc8ec5312941f1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to shorten the vectors of the primal basis using branch-and-bound, in <code>reductMinkowski</code>. <br /></td></tr>
<tr class="separator:a3888210b2464455cdc8ec5312941f1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f21ce2f060be920fc438a266e2939cc"><td class="memItemLeft" align="right" valign="top"><a id="a3f21ce2f060be920fc438a266e2939cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a3f21ce2f060be920fc438a266e2939cc">redBB0</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a3f21ce2f060be920fc438a266e2939cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to shorten the smallest vector of the primal basis using branch-and-bound, in <code>ShortestVector</code>. <br /></td></tr>
<tr class="separator:a3f21ce2f060be920fc438a266e2939cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be8b56fb83913fcd209c882c965d7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a5be8b56fb83913fcd209c882c965d7a9">preRedDieter</a> (int d)</td></tr>
<tr class="memdesc:a5be8b56fb83913fcd209c882c965d7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible.  <a href="#a5be8b56fb83913fcd209c882c965d7a9">More...</a><br /></td></tr>
<tr class="separator:a5be8b56fb83913fcd209c882c965d7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534443c5d2dd261205aff51b8e055f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a534443c5d2dd261205aff51b8e055f9a">preRedDieterRandomized</a> (int d, int seed)</td></tr>
<tr class="memdesc:a534443c5d2dd261205aff51b8e055f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible.  <a href="#a534443c5d2dd261205aff51b8e055f9a">More...</a><br /></td></tr>
<tr class="separator:a534443c5d2dd261205aff51b8e055f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da0675674ead09a4d97336d38aed8c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a1da0675674ead09a4d97336d38aed8c6">redDieter</a> (<a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a1da0675674ead09a4d97336d38aed8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest non-zero vector using norm <code>norm</code>.  <a href="#a1da0675674ead09a4d97336d38aed8c6">More...</a><br /></td></tr>
<tr class="separator:a1da0675674ead09a4d97336d38aed8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea947f8fc1cd2a41608ec08c9ba9e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a4ea947f8fc1cd2a41608ec08c9ba9e6f">redLLL</a> (double fact, std::int64_t maxcpt, int dim)</td></tr>
<tr class="memdesc:a4ea947f8fc1cd2a41608ec08c9ba9e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a4ea947f8fc1cd2a41608ec08c9ba9e6f">More...</a><br /></td></tr>
<tr class="separator:a4ea947f8fc1cd2a41608ec08c9ba9e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fb83ce72382904294392b850c1194b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a15fb83ce72382904294392b850c1194b">redLLLNTL</a> (double fact=0.999999, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> precision=QUADRUPLE, int dim=0)</td></tr>
<tr class="memdesc:a15fb83ce72382904294392b850c1194b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a15fb83ce72382904294392b850c1194b">More...</a><br /></td></tr>
<tr class="separator:a15fb83ce72382904294392b850c1194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6181b7355c23f08f59f012a5b27c12cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6181b7355c23f08f59f012a5b27c12cd">redLLLNTLExact</a> (double fact)</td></tr>
<tr class="memdesc:a6181b7355c23f08f59f012a5b27c12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than.  <a href="#a6181b7355c23f08f59f012a5b27c12cd">More...</a><br /></td></tr>
<tr class="separator:a6181b7355c23f08f59f012a5b27c12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19180cdcf1c22f665515583e5aa97d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a19180cdcf1c22f665515583e5aa97d22">redBKZ</a> (double fact=0.999999, std::int64_t blocksize=10, <a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> precision=QUADRUPLE, int dim=0)</td></tr>
<tr class="memdesc:a19180cdcf1c22f665515583e5aa97d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the BKZ (Block-Korkine-Zolotarev) basis reduction with the the coefficient <code>fact</code> and a block size <code>Blocksize</code>.  <a href="#a19180cdcf1c22f665515583e5aa97d22">More...</a><br /></td></tr>
<tr class="separator:a19180cdcf1c22f665515583e5aa97d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e0f32c36e4ccedffc2958fa174c4e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a48e0f32c36e4ccedffc2958fa174c4e8">reductMinkowski</a> (int d)</td></tr>
<tr class="memdesc:a48e0f32c36e4ccedffc2958fa174c4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the current basis to a Minkowski reduced basis with respect to the Euclidean norm, assuming that the first \(d\) vectors are already reduced and sorted.  <a href="#a48e0f32c36e4ccedffc2958fa174c4e8">More...</a><br /></td></tr>
<tr class="separator:a48e0f32c36e4ccedffc2958fa174c4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1645e5577168281b9801a51052673f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a3b1645e5577168281b9801a51052673f">pairwiseRedPrimal</a> (int i, int d)</td></tr>
<tr class="memdesc:a3b1645e5577168281b9801a51052673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise reductions.  <a href="#a3b1645e5577168281b9801a51052673f">More...</a><br /></td></tr>
<tr class="separator:a3b1645e5577168281b9801a51052673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c3426749c43fffcbe35a47ace6a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ac09c3426749c43fffcbe35a47ace6a5c">pairwiseRedDual</a> (int i)</td></tr>
<tr class="memdesc:ac09c3426749c43fffcbe35a47ace6a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise reductions, trying to reduce every other vector of the <em>dual</em> basis by adding multiples of the \(i\)-th vector.  <a href="#ac09c3426749c43fffcbe35a47ace6a5c">More...</a><br /></td></tr>
<tr class="separator:ac09c3426749c43fffcbe35a47ace6a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f54e32216fa781bd258cf565641d8ad"><td class="memItemLeft" align="right" valign="top"><a id="a2f54e32216fa781bd258cf565641d8ad"></a>
Dbl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a2f54e32216fa781bd258cf565641d8ad">getMinLength</a> ()</td></tr>
<tr class="memdesc:a2f54e32216fa781bd258cf565641d8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the shortest basis vector in the lattice. <br /></td></tr>
<tr class="separator:a2f54e32216fa781bd258cf565641d8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167acbaec68b7d5fffef88ebd80c5c44"><td class="memItemLeft" align="right" valign="top">Dbl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a167acbaec68b7d5fffef88ebd80c5c44">getMaxLength</a> ()</td></tr>
<tr class="memdesc:a167acbaec68b7d5fffef88ebd80c5c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the std::int64_test basis vector in the lattice.  <a href="#a167acbaec68b7d5fffef88ebd80c5c44">More...</a><br /></td></tr>
<tr class="separator:a167acbaec68b7d5fffef88ebd80c5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772697ab710e4bf44031a40d61c384a"><td class="memItemLeft" align="right" valign="top"><a id="a4772697ab710e4bf44031a40d61c384a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a4772697ab710e4bf44031a40d61c384a">setBoundL2</a> (const DblVec &amp;V, int dim1, int dim2)</td></tr>
<tr class="memdesc:a4772697ab710e4bf44031a40d61c384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower bound on the square length of the shortest vector in dimension \(i\) to \(V[i]\), for \(i\) going from <code>dim1</code> to <code>dim2</code>. <br /></td></tr>
<tr class="separator:a4772697ab710e4bf44031a40d61c384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff28dcbb3f221aa7eebd97ccc8c3a492"><td class="memItemLeft" align="right" valign="top"><a id="aff28dcbb3f221aa7eebd97ccc8c3a492"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#aff28dcbb3f221aa7eebd97ccc8c3a492">trace</a> (char *mess)</td></tr>
<tr class="memdesc:aff28dcbb3f221aa7eebd97ccc8c3a492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug function that print the primal and dual bases. <br /></td></tr>
<tr class="separator:aff28dcbb3f221aa7eebd97ccc8c3a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464b727ecbdf8ff20ff5232b4850f6c7"><td class="memItemLeft" align="right" valign="top"><a id="a464b727ecbdf8ff20ff5232b4850f6c7"></a>
<a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getIntLatticeBasis</b> ()</td></tr>
<tr class="separator:a464b727ecbdf8ff20ff5232b4850f6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ade6c748d8497b437a1eac7b38eb7a2eb"><td class="memItemLeft" align="right" valign="top"><a id="ade6c748d8497b437a1eac7b38eb7a2eb"></a>
static const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ade6c748d8497b437a1eac7b38eb7a2eb">SHORT_DIET</a> = 1000</td></tr>
<tr class="memdesc:ade6c748d8497b437a1eac7b38eb7a2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever the number of nodes in the branch-and-bound tree exceeds <code>SHORT_DIET</code> in the method <code>ShortestVector</code>, <code>PreRedDieterSV</code> is automatically set to <code>true</code> for the next call; otherwise it is set to <code>false</code>. <br /></td></tr>
<tr class="separator:ade6c748d8497b437a1eac7b38eb7a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abe37789fa1f2c3dc533fc3fd335db1"><td class="memItemLeft" align="right" valign="top"><a id="a6abe37789fa1f2c3dc533fc3fd335db1"></a>
static const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a6abe37789fa1f2c3dc533fc3fd335db1">SHORT_LLL</a> = 1000</td></tr>
<tr class="memdesc:a6abe37789fa1f2c3dc533fc3fd335db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever the number of nodes in the branch-and-bound tree exceeds <code>SHORT_LLL</code> in the method <code>ShortestVector</code>, <code>PreRedLLLSV</code> is automatically set to <code>true</code> for the next call; otherwise it is set to <code>false</code>. <br /></td></tr>
<tr class="separator:a6abe37789fa1f2c3dc533fc3fd335db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21411a7785509a919cdaa1fd8c89cb85"><td class="memItemLeft" align="right" valign="top"><a id="a21411a7785509a919cdaa1fd8c89cb85"></a>
static const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a21411a7785509a919cdaa1fd8c89cb85">MINK_LLL</a> = 500000</td></tr>
<tr class="memdesc:a21411a7785509a919cdaa1fd8c89cb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever the number of nodes in the branch-and-bound tree exceeds <code>MINK_LLL</code> in the method <code>reductMinkowski</code>, <code>PreRedLLLRM</code> is automatically set to <code>true</code> for the next call; otherwise it is set to <code>false</code>. <br /></td></tr>
<tr class="separator:a21411a7785509a919cdaa1fd8c89cb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c6442651793a2a12133a41732b7662"><td class="memItemLeft" align="right" valign="top">static const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#ac8c6442651793a2a12133a41732b7662">MAX_PRE_RED</a> = 1000000</td></tr>
<tr class="memdesc:ac8c6442651793a2a12133a41732b7662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of transformations in the method <code>PreRedDieter</code>.  <a href="#ac8c6442651793a2a12133a41732b7662">More...</a><br /></td></tr>
<tr class="separator:ac8c6442651793a2a12133a41732b7662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569aff0057450a510b456fae95028e71"><td class="memItemLeft" align="right" valign="top">static std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a569aff0057450a510b456fae95028e71">maxNodesBB</a> = 10000000</td></tr>
<tr class="memdesc:a569aff0057450a510b456fae95028e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of nodes in the branch-and-bound tree when calling <code>ShortestVector</code> or <code>reductMinkowski</code>.  <a href="#a569aff0057450a510b456fae95028e71">More...</a><br /></td></tr>
<tr class="separator:a569aff0057450a510b456fae95028e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pre-reduction flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These boolean variables indicate which type of pre-reduction is to be performed for <code>ShortestVector</code> (SV) and for <code>reductMinkowski</code> (RM).</p>
<p><code>Dieter</code> means the pairwise pre-reduction as in the method <code>PreRedDieter</code>. <code>LLL</code> means the LLL reduction of Lenstra, Lenstra, and Lov√°sz. The variable <code>PreRedDieterSV</code> is originally set to <code>true</code> and the two others are originally set to <code>false</code>. These variables are reset automatically depending on the thresholds <code>MinkLLL, ShortDiet, ShortLLL</code> as explained above. </p>
</div></td></tr>
<tr class="memitem:a90c41078ee868acb8ed214069dc438a6"><td class="memItemLeft" align="right" valign="top"><a id="a90c41078ee868acb8ed214069dc438a6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedDieterSV</b> = false</td></tr>
<tr class="separator:a90c41078ee868acb8ed214069dc438a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427d608a4aecf957a28dccf5646bd716"><td class="memItemLeft" align="right" valign="top"><a id="a427d608a4aecf957a28dccf5646bd716"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedLLLSV</b> = false</td></tr>
<tr class="separator:a427d608a4aecf957a28dccf5646bd716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a72f290d61d6d73d99170f24dc4de5"><td class="memItemLeft" align="right" valign="top"><a id="aa3a72f290d61d6d73d99170f24dc4de5"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedLLLRM</b> = false</td></tr>
<tr class="separator:aa3a72f290d61d6d73d99170f24dc4de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9201eb273af983502fc5f12e48141eb0"><td class="memItemLeft" align="right" valign="top"><a id="a9201eb273af983502fc5f12e48141eb0"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreRedBKZ</b> = true</td></tr>
<tr class="separator:a9201eb273af983502fc5f12e48141eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Int, typename BasInt, typename BasIntVec, typename BasIntMat, typename Dbl, typename DblVec, typename RedDbl, typename RedDblVec, typename RedDblMat&gt;<br />
class LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;</h3>

<p>For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and to find the shortest non-zero vector of the lattice using pre-reductions and a branch-and-bound (BB) algorithm <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[17]</a>&thinsp;. </p>
<p>It also implements the method of Lenstra, Lenstra and Lovasz (LLL) <a class="el" href="../../d0/de3/citelist.html#CITEREF_mLEN82a">[23]</a>&thinsp; as well as the method of Dieter <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[9]</a>&thinsp; to reduce a lattice basis. The Minkowski, LLL and Branch-and-bound Reduction do not need the dual lattice. Nonetheless, if a <a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html" title="This class represents a lattice and its basis and offers tools to do basic manipulations on lattice b...">IntLatticeBasis</a> object with a true with-dual flag is given to a <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html" title="For a given lattice, this class implements methods to reduce its basis in the sense of Minkowski and ...">Reducer</a>, the duality will be preserve during reduction. Beside, the algorithm BKZ implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> Library can be used as a prereduction before the Branch-and-Bound. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8211e2e27585eb711a42d69ed4ed255d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8211e2e27585eb711a42d69ed4ed255d">&#9670;&nbsp;</a></span>Reducer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::<a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d89/classLatticeTester_1_1IntLatticeBasis.html">IntLatticeBasis</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl &gt; &amp;&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Initializes the reducer to work on lattice <code>lat</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a23a04bb86d44bc7443ce327e3f6f16c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a04bb86d44bc7443ce327e3f6f16c4">&#9670;&nbsp;</a></span>calculCholeski()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::calculCholeski </td>
          <td>(</td>
          <td class="paramtype">RedDblVec &amp;&#160;</td>
          <td class="paramname"><em>DC2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedDblMat &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a Choleski decomposition of the basis. </p>
<p>Returns in <code>C0</code> the elements of the upper triangular matrix of the Choleski decomposition that are above the diagonal. Returns in <code>DC2</code> the squared elements of the diagonal. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>.</p>

</div>
</div>
<a id="a5f8fe771397c464ffa4b406e517db9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fe771397c464ffa4b406e517db9b7">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt; &amp;&#160;</td>
          <td class="paramname"><em>red</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the reducer <code>red</code> into this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Encore utile? </dd></dl>

</div>
</div>
<a id="a167acbaec68b7d5fffef88ebd80c5c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167acbaec68b7d5fffef88ebd80c5c44">&#9670;&nbsp;</a></span>getMaxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename BasInt, typename BasIntVec, typename BasIntMat, typename Dbl, typename DblVec, typename RedDbl, typename RedDblVec, typename RedDblMat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dbl <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::getMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the std::int64_test basis vector in the lattice. </p>
<p>Used in Beyer Test. </p>

</div>
</div>
<a id="ac09c3426749c43fffcbe35a47ace6a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c3426749c43fffcbe35a47ace6a5c">&#9670;&nbsp;</a></span>pairwiseRedDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::pairwiseRedDual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise reductions, trying to reduce every other vector of the <em>dual</em> basis by adding multiples of the \(i\)-th vector. </p>
<p>That may change the \(i\)-th vector in the primal basis. Each such dual reduction is actually performed only if that does not increase the length of vector \(i\) in the primal basis. Always uses the Euclidean norm. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>, and <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">LatticeTester::ModifVect()</a>.</p>

</div>
</div>
<a id="a3b1645e5577168281b9801a51052673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1645e5577168281b9801a51052673f">&#9670;&nbsp;</a></span>pairwiseRedPrimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::pairwiseRedPrimal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise reductions. </p>
<p>This method tries to reduce each basis vector with index larger than \(d\) and distinct from \(i\) by adding to it a multiple of the \(i\)-th vector. Always uses the Euclidean norm. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>, and <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">LatticeTester::ModifVect()</a>.</p>

</div>
</div>
<a id="a5be8b56fb83913fcd209c882c965d7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be8b56fb83913fcd209c882c965d7a9">&#9670;&nbsp;</a></span>preRedDieter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::preRedDieter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible. </p>
<p>Always use the Euclidean norm. </p>

</div>
</div>
<a id="a534443c5d2dd261205aff51b8e055f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534443c5d2dd261205aff51b8e055f9a">&#9670;&nbsp;</a></span>preRedDieterRandomized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::preRedDieterRandomized </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the reductions of the preceding two methods using cyclically all values of \(i\) (only for \(i &gt; d\) in the latter case) and stops after either <code>MaxPreRed</code> successful transformations have been achieved or no further reduction is possible. </p>
<p>Always use the Euclidean norm. The choice of i is randomized. </p>

</div>
</div>
<a id="a19180cdcf1c22f665515583e5aa97d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19180cdcf1c22f665515583e5aa97d22">&#9670;&nbsp;</a></span>redBKZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redBKZ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>blocksize</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>QUADRUPLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the BKZ (Block-Korkine-Zolotarev) basis reduction with the the coefficient <code>fact</code> and a block size <code>Blocksize</code>. </p>
<p>The precision can be given. See <a class="el" href="../../db/da7/Const_8h.html" title="This module contains global constants used in LatticeTester. ">Const.h</a> for further information. </p>

<p class="reference">References <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a19180cdcf1c22f665515583e5aa97d22">LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redBKZ()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a19180cdcf1c22f665515583e5aa97d22">LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redBKZ()</a>.</p>

</div>
</div>
<a id="a1da0675674ead09a4d97336d38aed8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da0675674ead09a4d97336d38aed8c6">&#9670;&nbsp;</a></span>redDieter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redDieter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the shortest non-zero vector using norm <code>norm</code>. </p>
<p>Returns <code>true</code> upon success. Uses the algorithm of Dieter <a class="el" href="../../d0/de3/citelist.html#CITEREF_rDIE75a">[9]</a>&thinsp; given in Knuth <a class="el" href="../../d0/de3/citelist.html#CITEREF_rKNU98a">[16]</a>&thinsp;. </p>

<p class="reference">References <a class="el" href="../../d2/d5a/namespaceNTL.html#a07b6d8586b6a40e65a3bee1608d3e389">NTL::conv()</a>, and <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">LatticeTester::ModifVect()</a>.</p>

</div>
</div>
<a id="a4ea947f8fc1cd2a41608ec08c9ba9e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea947f8fc1cd2a41608ec08c9ba9e6f">&#9670;&nbsp;</a></span>redLLL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redLLL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>maxcpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. </li>
</ol>

</div>
</div>
<a id="a15fb83ce72382904294392b850c1194b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fb83ce72382904294392b850c1194b">&#9670;&nbsp;</a></span>redLLLNTL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redLLLNTL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em> = <code>0.999999</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>QUADRUPLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. This version is implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> Library with approximate number with arbitrary precision. The precision can be given. See <a class="el" href="../../db/da7/Const_8h.html" title="This module contains global constants used in LatticeTester. ">Const.h</a> for further information. </li>
</ol>

<p class="reference">References <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a15fb83ce72382904294392b850c1194b">LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redLLLNTL()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html#a15fb83ce72382904294392b850c1194b">LatticeTester::Reducer&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redLLLNTL()</a>.</p>

</div>
</div>
<a id="a6181b7355c23f08f59f012a5b27c12cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6181b7355c23f08f59f012a5b27c12cd">&#9670;&nbsp;</a></span>redLLLNTLExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::redLLLNTLExact </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a LLL (Lenstra-Lenstra-Lovasz) basis reduction up to dimension <code>dim</code> with coefficient <code>fact</code>, which must be smaller than. </p>
<ol type="1">
<li>If <code>fact</code> is closer to 1, the basis will be (typically) "more
reduced", but that will require more work. The reduction algorithm is applied until <code>maxcpt</code> successful transformations have been done. Always uses the Euclidean norm. This version is implemented in the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="The two floowing two classes are copies from NTL::Vec&lt;T&gt; and NTL::Mat&lt;T&gt;, but they contain additional...">NTL</a> Library with exact number (arbitrary precision RR) </li>
</ol>

</div>
</div>
<a id="a48e0f32c36e4ccedffc2958fa174c4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e0f32c36e4ccedffc2958fa174c4e8">&#9670;&nbsp;</a></span>reductMinkowski()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::reductMinkowski </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the current basis to a Minkowski reduced basis with respect to the Euclidean norm, assuming that the first \(d\) vectors are already reduced and sorted. </p>
<p>If <code>MaxNodesBB</code> is exceeded during one of the branch-and-bound step, the method aborts and returns <code>false</code>. Otherwise it returns <code>true</code>, the basis is reduced and sorted by vector lengths (the shortest vector is <code>V[0]</code> and the std::int64_test is <code>V[Dim-1]</code>). </p>

</div>
</div>
<a id="a2f8992d37e76b9c4ab29bab91f32f57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8992d37e76b9c4ab29bab91f32f57f">&#9670;&nbsp;</a></span>shortestVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::shortestVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d74/namespaceLatticeTester.html#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the shortest non-zero vector of this lattice with respect to norm <code>norm</code> using branch-and-bound and the algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rLEC97c">[17]</a>&thinsp;. </p>
<p>The <code>Norm</code> member of this object will be changed to <code>norm</code>. If <code>MaxNodesBB</code> is exceeded during one of the branch-and-bounds, the method aborts and returns <code>false</code>. Otherwise, it returns <code>true</code>. Uses the pre-reduction algorithms of Dieter and of Lenstra-Lenstra-Lovasz. Advice: must perform pre-reduction before using this Branch-and-Bound method on high dimension basis. </p>

</div>
</div>
<a id="aee0edaf68051f1f63d8f892a4e7c0352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0edaf68051f1f63d8f892a4e7c0352">&#9670;&nbsp;</a></span>transformStage3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename BasInt , typename BasIntVec , typename BasIntMat , typename Dbl , typename DblVec , typename RedDbl , typename RedDblVec , typename RedDblMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::transformStage3 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method used in <code>reductMinkowski</code> to perform a transformation of stage 3 described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rAFF85a">[1]</a>&thinsp;. </p>
<p>Also used in <code>ShortestVector</code>. Assumes that \(\sum_{i=1}^t z_i V_i\) is a short vector that will enter the basis. Tries to reduce some vectors by looking for indices \(i &lt; j\) such that \(|z_j| &gt; 1\) and \(q=\lfloor z_i/z_j\rfloor\not0\), and adding \(q V_i\) to \(V_j\) when this happens. Returns in \(k\) the last index \(j\) such that \(|z_j|=1\). </p>

<p class="reference">References <a class="el" href="../../d8/d74/namespaceLatticeTester.html#ad43d2de9716e712790093eff2c12631f">LatticeTester::ModifVect()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac8c6442651793a2a12133a41732b7662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c6442651793a2a12133a41732b7662">&#9670;&nbsp;</a></span>MAX_PRE_RED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename BasInt, typename BasIntVec, typename BasIntMat, typename Dbl, typename DblVec, typename RedDbl, typename RedDblVec, typename RedDblMat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::int64_t <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::MAX_PRE_RED = 1000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of transformations in the method <code>PreRedDieter</code>. </p>
<p>After <code>MAX_PRE_RED</code> successful transformations have been performed, the prereduction is stopped. </p>

</div>
</div>
<a id="a569aff0057450a510b456fae95028e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569aff0057450a510b456fae95028e71">&#9670;&nbsp;</a></span>maxNodesBB</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename BasInt, typename BasIntVec, typename BasIntMat, typename Dbl, typename DblVec, typename RedDbl, typename RedDblVec, typename RedDblMat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t <a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">LatticeTester::Reducer</a>&lt; Int, BasInt, BasIntVec, BasIntMat, Dbl, DblVec, RedDbl, RedDblVec, RedDblMat &gt;::maxNodesBB = 10000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of nodes in the branch-and-bound tree when calling <code>ShortestVector</code> or <code>reductMinkowski</code>. </p>
<p>When this number is exceeded, the method aborts and returns <code>false</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>latticetester/include/latticetester/Reducer.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li><li class="navelem"><a class="el" href="../../d8/de3/classLatticeTester_1_1Reducer.html">Reducer</a></li>
    <li class="footer">Generated on Mon Jul 30 2018 09:01:15 for LatNet Builder Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
