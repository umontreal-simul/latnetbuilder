<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatNet Builder Manual: Implementation Notes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LatNet Builder Manual
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">Software Package for Constructing Highly Uniform Point Sets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/d2e/libtut_impl.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementation Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="libtut_impl_spaghetti"></a>
Relations between LatBuilder and NetBuilder</h1>
<p class="">The two parts of the software are mostly independent, but some dependencies were introduced so as to limit code duplication. More precisely:</p>
<ul>
<li><a class="el" href="../../d1/d74/namespaceLatBuilder.html" title="LatBuilder namespace.">LatBuilder</a> only uses some output formatting functionalities from <a class="el" href="../../dc/dc5/namespaceNetBuilder.html" title="NetBuilder namespace.">NetBuilder</a>.</li>
<li><a class="el" href="../../dc/dc5/namespaceNetBuilder.html" title="NetBuilder namespace.">NetBuilder</a> uses the following parts of <a class="el" href="../../d1/d74/namespaceLatBuilder.html" title="LatBuilder namespace.">LatBuilder</a>:<ul>
<li>the interlacing functionalities (<a class="el" href="../../da/db0/namespaceLatBuilder_1_1Interlaced.html">LatBuilder::Interlaced</a>), e.g. the interlaced weights and kernels.</li>
<li>the kernels (<a class="el" href="../../d8/da6/namespaceLatBuilder_1_1Kernel.html">LatBuilder::Kernel</a>)</li>
<li>the coordinate-uniform evaluation algorithm (<a class="el" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html">LatBuilder::MeritSeq</a>) for kernel-based figures of merit</li>
<li>the Sequence framework explained below</li>
<li>some parts of the parser, output formatting functionalities and additional technical utilities</li>
</ul>
</li>
</ul>
<p class="">In <a class="el" href="../../d1/d74/namespaceLatBuilder.html" title="LatBuilder namespace.">LatBuilder</a>, the coordinate-uniform evaluation algorithm is based on viewing fully-projection regular lattice rules as permutations of the multiples of \(\frac1n\). The computation rules for these permutations are based on modular arithmetic in \(\mathbb Z\) for ordinary lattice rules (resp. arithmetic in the Laurent formal series space for polynomial lattice rules). This point of view can be extended to digital nets, by changing the computation rule for the permutations. The rule relies on linear algebra in \(\mathbb F_2\). All these rules are detailed on this <a class="el" href="../../dc/d5a/feats_pointsets.html">page</a>.</p>
<p class="">These operations are implemented in the <a class="el" href="../../d3/d02/classLatBuilder_1_1SizeParam.html">LatBuilder::SizeParam</a> and <a class="el" href="../../d5/dd3/classLatBuilder_1_1Storage.html">LatBuilder::Storage</a> classes templated by the LatticeType enumeration. The actual implementation is in the Stride inner class. To reuse code from <a class="el" href="../../d1/d74/namespaceLatBuilder.html" title="LatBuilder namespace.">LatBuilder</a>, in particular the coordinate-uniform evaluation algorithm, we added a new value (<a class="el" href="../../#ggaea6cf3308d8b172dc4d8446e81f5c9f2a6d803302c669b84818dfd9d88534e1d2">LatBuilder::LatticeType::DIGITAL</a>) to this enumeration, and implemented the above-mentioned classes. Although the notion of digital lattice does not make sense mathematically, it does make sense from the implementation standpoint. Details on the coordinate-uniform evaluation algorithm are available in the original reference paper <a class="el" href="../../d0/de3/citelist.html#CITEREF_vLEC16a">[19]</a>.</p>
<h1><a class="anchor" id="libtut_impl_seq"></a>
Sequence</h1>
<p class="">In multiple situations, LatNet Builder needs to access arrays of values that can interchangeably be computed on-the-fly or pre-computed. The concept of <em>sequence</em>, in the sense of ordered list rather than infinite mathematical sequence, provides in LatNet Builder a unified interface for both. The elements of a sequence are accessed via immutable iterators (<code>const_iterator</code>) with the standard syntax as used for the standard C++ containers, as in the following example: </p><div class="fragment"><div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div><div class="line"><span class="keywordflow">for</span> (MySeq::const_iterator it = seq.begin(); it != seq.end(); ++it)</div><div class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</div></div><!-- fragment --><p> Or, using the new C++11 <code>auto</code> keyword and <code>for</code> syntax: </p><div class="fragment"><div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : seq)</div><div class="line">   std::cout &lt;&lt; elem &lt;&lt; std::endl;</div></div><!-- fragment --><p> Concrete examples are given in the tutorial in sections <a class="el" href="../../dd/df1/libtut_lat_genseq.html">Sequences of Generator Values</a>, <a class="el" href="../../d5/d48/libtut_lat_latseq.html">Sequences of Lattice Definitions</a> and <a class="el" href="../../da/dd0/libtut_lat_meritseq.html">Sequences of Merit Values</a> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d60/namespaceLatBuilder_1_1GenSeq.html" title="Sequences of generator values.">LatBuilder::GenSeq</a> LatBuilder::GenSeqSeq <a class="el" href="../../d0/d64/namespaceLatBuilder_1_1LatSeq.html" title="Sequences of Lattices.">LatBuilder::LatSeq</a> <a class="el" href="../../da/d9a/namespaceLatBuilder_1_1MeritSeq.html" title="Sequences of merit values.">LatBuilder::MeritSeq</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <a class="el" href="../../dc/d23/namespaceLatBuilder_1_1TextStream.html" title="Overloaded stream operators.">LatBuilder::TextStream</a> namespace provides streaming operators to iterate over sequences with a more compact syntax: <div class="fragment"><div class="line"><span class="keyword">using</span> TextStream::operator&lt;&lt;;</div><div class="line">MySeq seq; <span class="comment">// must implement begin() and end()</span></div><div class="line">std::cout &lt;&lt; seq &lt;&lt; std::endl;</div></div><!-- fragment --> Concrete examples are given in the tutorial in section <a class="el" href="../../d6/d44/libtut_lat_textstream.html">Text Output</a> .</dd></dl>
<h1><a class="anchor" id="libtut_impl_bridgeseq"></a>
Bridge Sequence</h1>
<p class="">The values in a sequence often need to be mapped to other values, possibly of a different type. For that purpose, LatNet Builder introduces the concept of a <em>bridge sequence</em>, which contains the mapped elements in the same order as the sequence it is based on.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db3/classLatBuilder_1_1BridgeSeq.html" title="Bridge CRTP class for sequence based on another type of sequence, with elements computed by the deriv...">LatBuilder::BridgeSeq</a></dd></dl>
<h1><a class="anchor" id="libtut_impl_polymorphism"></a>
Static Polymorphism</h1>
<p class="">Traditional object-oriented programming makes use of dynamic polymorphism, where the exact class of an object is resolved at execution time, dynamically. It follows that polymorphic member function calls cannot be inlined, so it is often not advisable to place such a call in the core of a loop with many iterations, at the risk of cumulating inderections due to both polymorphism and function calls.</p>
<p class="">Some algorithms implemented by LatNet Builder come in several variants which require either polymorphic function calls inside such loops or a large amount of duplicated code with tiny differences. C++ allows to circumvent that problem through the use of <em>static polymorphism</em>, which enables compile-time resolution of the types together with member function inlining.</p>
<p class="">In some places, static polymorphism is used regardless that dynamic polymorphism could have been used without any notable performance loss, in order to maintain a consistent design. We prefer making common usage patterns of LatNet Builder's classes easier to recognize, even if that means a little bit more verbose code in places.</p>
<p class="">The most obvious example is the case of sequence classes. Their member functions <code>begin()</code> and <code>end()</code> return iterators; the type of an iterator is often specific to the type of the sequence it is pointing to.</p>
<p class="">Another example is the size parameter is represented by a different class depending on whether ordinary or embedded lattices are considered. In both cases, the class implements a <code>numPoints()</code> member function, that returns the number of points in the lattice, and that is accessed frequently in some parts of the code. In a traditional object-oriented approach, the two classes would derive from the same abstract base class, and would have required runtime object-type resolution at the call points of <code>numPoints()</code>. With the static polymorphism approach, the <code>numPoints()</code> function can be efficiently inlined by the compiler, thus avoiding both the overhead due to the function call and to runtime object-type resolution.</p>
<h1><a class="anchor" id="libtut_impl_concepts"></a>
Concept</h1>
<p class="">Concepts in C++ can be thought of as the static-polymorphism counterpart of dynamic-polymorphism interfaces. Like interfaces, concepts can specify requirements on the members of a class; unlike interfaces, the data types of the arguments and of the return value of a member function can differ across classes implementing the same concept. Furthermore, a concept can require type definitions (typedefs or nested classes) inside of a class. A well-known example of concept it that of <code>iterator</code> or of <code>const_iterator</code> from the STL.</p>
<p class="">Although requirements on the types are not described with concepts definitions in LatNet Builder, but the code is built around the idiom of concepts.</p>
<p class="">By convention in LatNet Builder, classes representing the same concept are regrouped in the same namespace.</p>
<p class="">The most important concepts are described by means of example in the <a class="el" href="../../da/d6f/libtut.html">Library Tutorial</a>.</p>
<h1><a class="anchor" id="libtut_impl_memory"></a>
Memory Management</h1>
<p class="">In LatNet Builder, when a non-trivial object is no longer needed in its scope after it is passed as an argument to a constructor or factory function, it is generally std::move()'d to the constructor or function in question. The compiler takes care of using the default move constructor on the object that is passed to the constructor and thus avoids copying the object, which can safely be stored as a class member of the owner object. Generator sequences (see the GenSeq namespace) are an example of non-trivial objects that are transferred to other owner objects using this mechanism. Weights objects, such as instances of <a class="el" href="../../da/d3e/classLatticeTester_1_1ProductWeights.html" title="Product weights.">LatticeTester::ProductWeights</a> or of <a class="el" href="../../d1/db4/classLatticeTester_1_1ProjectionDependentWeights.html" title="Projection-dependent weights.">LatticeTester::ProjectionDependentWeights</a>, are other examples of non-trivial objects, but because they are polymorphic, they are stored using a std::unique_ptr, which in turn, is passed using either std::move() or, equivalently, std::unique_ptr::release(). There are a few exceptions to that ownership policy, notably figures of merit like instances of WeightedFigureOfMerit or of CoordUniformFigureOfMerit. Some classes store references to such objects, so the objects themselves are also stored using std::unique_ptr so that references remain valid even after the object ownership has changed.</p>
<h1><a class="anchor" id="libtut_impl_cpp11"></a>
Usage of the C++14 Standard</h1>
<p class="">LatNet Builder makes uses of the following C++11 features:</p><ul>
<li>auto-typed variables</li>
<li>range-based for-loop</li>
<li>std::function and std::bind</li>
<li>rvalue references</li>
<li>move constructors and assignment operators</li>
<li>static assertions</li>
<li>extern templates</li>
<li>null pointer constant</li>
<li>strongly typed enums</li>
<li>initializer lists</li>
<li>non-static data member initializers</li>
<li>template aliases</li>
</ul>
<p class="">LatNet Builder makes uses of the following C++14 features:</p><ul>
<li>std::make_unique</li>
</ul>
<h1><a class="anchor" id="libtut_impl_boost"></a>
Usage of the Boost C++ Libraries</h1>
<p class="">The LatNet Builder library depends on the following <a href="http://www.boost.org/">Boost libraries</a>: </p><ul>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/math/doc/html/index.html">Math</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/numeric/ublas/doc/index.html">uBLAS</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/iterator/doc/index.html">Iterator</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/doc/html/accumulators.html">Accumulators</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/doc/html/signals2.html">Signals2</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/tokenizer/index.html">Tokenizer</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_lexical_cast.html">Lexical Cast</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/doc/html/program_options.html">Program Options</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/algorithm/doc/html/index.html">Algorithm</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/system/doc/index.html">System</a> </li>
<li>
<a href="https://www.boost.org/doc/libs/1_67_0/libs/filesystem/doc/index.htm">Filesystem</a> </li>
</ul>
<p class="">Only the Program Options, the System and the Filesystem libraries require building and linking; the others are header-only libraries.</p>
<h1><a class="anchor" id="libtut_impl_fftw"></a>
Usage of FFTW</h1>
<p class="">The fast CBC implementation of LatNet Builder, as well as the computation of the \(R_\alpha\) criterion, depends on the <a href="http://www.fftw.org/">FFTW library</a>.</p>
<h1><a class="anchor" id="libtut_impl_ntl"></a>
Usage of NTL</h1>
<p class="">LatNet Builder also depends on the <a href="http://www.shoup.net/ntl/">NTL library</a> for arithmetic computations (lattices, polynomials, etc.).</p>
<h1><a class="anchor" id="libtut_impl_latticetester"></a>
Usage of LatticeTester</h1>
<p class="">LatNet Builder uses <a href="https://github.com/umontreal-simul/latticetester">LatticeTester</a>, a software library to compute theoretical measures of uniformity for lattices. This library is embedded in the code source of LatNet Builder and in the binary distribution packages. <br />
 </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">LatNet Builder Manual</a></li><li class="navelem"><a class="el" href="../../da/d6f/libtut.html">Library Tutorial</a></li>
    <li class="footer">Generated on Mon Jul 30 2018 11:56:49 for LatNet Builder Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
